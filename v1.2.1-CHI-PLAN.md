# v1.2.1 "Modern Foundation" Implementation Plan
*Chi Router Integration + Code Organization*

## üéØ **Enhanced Release Goals**
- **Performance**: +100-150% improvement (159‚Üí300+ req/sec) 
- **Architecture**: Chi router + clean middleware structure
- **Code Quality**: Professional API design within single file
- **Compatibility**: 100% backward compatibility maintained
- **Risk**: LOW ‚ö†Ô∏è (proven framework + safe optimizations)

---

## üîÑ **Strategy Shift: From Refactoring to Evolution**

### **Original v1.2.1 Plan**: Internal refactoring of stdlib approach
### **Enhanced v1.2.1 Plan**: Chi integration + modern architecture

**Why the change?**
- Chi provides **professional routing** without complexity
- **Immediate performance boost** from battle-tested optimizations
- **Better foundation** for future features (middleware, metrics, etc.)
- **Industry standard** approach while maintaining simplicity

---

## üìã **Two-Week Implementation Plan**

### **Week 1: Chi Integration Foundation**

#### **Day 1-2: Dependencies and Basic Structure**
```bash
# Add Chi dependency
go get github.com/go-chi/chi/v5
go mod tidy
```

```go
// main.go - New imports section
package main

import (
    "flag"
    "log"
    "net/http"
    "net/http/httputil"
    "net/url"
    "strings"
    "sync/atomic"
    "time"
    
    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "gopkg.in/yaml.v2"
)

// Single dependency addition - Chi router
```

#### **Day 3-4: Router Setup and Basic Routing**
```go
// -------------------------
// Router Configuration
// -------------------------

func createRouter(cfg *Config) *chi.Mux {
    r := chi.NewRouter()
    
    // Essential middleware
    r.Use(middleware.Recoverer)  // Panic recovery
    r.Use(middleware.RealIP)     // Real IP extraction
    r.Use(middleware.RequestID)  // Request tracking
    
    // Optional development middleware
    if *debug {
        r.Use(middleware.Logger)
    }
    
    // Setup tenant routing
    setupTenantRouting(r, cfg)
    
    return r
}

func setupTenantRouting(r *chi.Mux, cfg *Config) {
    for _, tenant := range cfg.Tenants {
        router := createTenantRouter(tenant)
        
        if len(tenant.Domains) > 0 && tenant.PathPrefix != "" {
            // Hybrid routing: domain + path
            setupHybridRouting(r, tenant, router)
        } else if len(tenant.Domains) > 0 {
            // Host-only routing
            setupHostRouting(r, tenant, router)
        } else if tenant.PathPrefix != "" {
            // Path-only routing (backward compatibility)
            setupPathRouting(r, tenant, router)
        }
        
        startHealthChecks(tenant, router)
        log.Printf("tenant %s configured with %d backend(s)", tenant.Name, len(router.backends))
    }
}
```

#### **Day 5-7: Middleware Implementation**
```go
// -------------------------
// Custom Middleware
// -------------------------

// Host matching middleware for domain-based routing
func HostMatchMiddleware(domains []string) func(http.Handler) http.Handler {
    domainMap := make(map[string]bool, len(domains))
    for _, domain := range domains {
        domainMap[domain] = true
    }
    
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            host := extractHostFast(r.Host)
            if domainMap[host] {
                next.ServeHTTP(w, r)
            } else {
                http.NotFound(w, r)
            }
        })
    }
}

// Tenant proxy middleware
func TenantProxyMiddleware(router *tenantRouter) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            backend := router.nextBackend()
            if backend == nil {
                http.Error(w, "no backend available", http.StatusBadGateway)
                return
            }
            
            proxy := createOptimizedProxy(backend, r)
            proxy.ServeHTTP(w, r)
        })
    }
}

// Performance optimization middleware
func OptimizedTransportMiddleware() func(http.Handler) http.Handler {
    transport := &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     90 * time.Second,
        WriteBufferSize:     32 * 1024,
        ReadBufferSize:      32 * 1024,
    }
    
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // Add optimized transport to context for proxy creation
            ctx := context.WithValue(r.Context(), "transport", transport)
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}
```

### **Week 2: Routing Logic and Optimization**

#### **Day 8-10: Routing Logic Implementation**
```go
// -------------------------
// Routing Setup Functions
// -------------------------

func setupHybridRouting(r *chi.Mux, tenant Tenant, router *tenantRouter) {
    // Domain + path combination routing
    r.Route(tenant.PathPrefix, func(r chi.Router) {
        r.Use(HostMatchMiddleware(tenant.Domains))
        r.Use(TenantProxyMiddleware(router))
        r.HandleFunc("/*", func(w http.ResponseWriter, r *http.Request) {
            // Request reaches here after middleware processing
            // Middleware has already handled the proxying
        })
    })
    
    for _, domain := range tenant.Domains {
        log.Printf("tenant %s: hybrid routing for domain %s with path %s", 
                   tenant.Name, domain, tenant.PathPrefix)
    }
}

func setupHostRouting(r *chi.Mux, tenant Tenant, router *tenantRouter) {
    // Host-only routing
    r.Group(func(r chi.Router) {
        r.Use(HostMatchMiddleware(tenant.Domains))
        r.Use(TenantProxyMiddleware(router))
        r.HandleFunc("/*", func(w http.ResponseWriter, r *http.Request) {
            // Middleware handles everything
        })
    })
    
    for _, domain := range tenant.Domains {
        log.Printf("tenant %s: host-based routing for domain %s", tenant.Name, domain)
    }
}

func setupPathRouting(r *chi.Mux, tenant Tenant, router *tenantRouter) {
    // Path-only routing (backward compatibility)
    r.Route(tenant.PathPrefix, func(r chi.Router) {
        r.Use(TenantProxyMiddleware(router))
        r.HandleFunc("/*", func(w http.ResponseWriter, r *http.Request) {
            // Middleware handles everything
        })
    })
    
    log.Printf("tenant %s: path-based routing for prefix %s", tenant.Name, tenant.PathPrefix)
}
```

#### **Day 11-12: Proxy Optimization**
```go
// -------------------------
// Optimized Proxy Creation
// -------------------------

func createOptimizedProxy(backend *backend, r *http.Request) *httputil.ReverseProxy {
    proxy := httputil.NewSingleHostReverseProxy(backend.url)
    
    // Get optimized transport from context
    if transport, ok := r.Context().Value("transport").(*http.Transport); ok {
        proxy.Transport = transport
    }
    
    proxy.Director = func(req *http.Request) {
        configureProxyRequest(req, backend, r)
    }
    
    proxy.ModifyResponse = func(resp *http.Response) error {
        return optimizeProxyResponse(resp)
    }
    
    return proxy
}

func configureProxyRequest(req *http.Request, backend *backend, originalReq *http.Request) {
    req.URL.Scheme = backend.url.Scheme
    req.URL.Host = backend.url.Host
    
    // Smart path rewriting based on route context
    if routeCtx := chi.RouteContext(originalReq.Context()); routeCtx != nil {
        if routePattern := routeCtx.RoutePattern(); routePattern != "" {
            // Extract prefix from route pattern for path rewriting
            rewritePathWithPattern(req, routePattern)
        }
    }
    
    // Merge query parameters
    mergeQueryParameters(req, backend)
}

func optimizeProxyResponse(resp *http.Response) error {
    resp.Header.Set("Server", "keystone-gateway/1.2.1")
    resp.Header.Set("X-Proxy", "keystone")
    return nil
}
```

#### **Day 13-14: Integration and Testing**
```go
// -------------------------
// Updated Main Function
// -------------------------

func main() {
    cfgPath := flag.String("config", "config.yaml", "path to YAML config")
    addr := flag.String("addr", ":8080", "listen address")
    debug := flag.Bool("debug", false, "enable debug logging")
    flag.Parse()

    cfg, err := loadConfig(*cfgPath)
    if err != nil {
        log.Fatalf("failed to load config: %v", err)
    }

    router := createRouter(cfg)
    
    log.Printf("Keystone Gateway v1.2.1 listening on %s", *addr)
    if err := http.ListenAndServe(*addr, router); err != nil {
        log.Fatal(err)
    }
}

// File structure remains single file, ~300 lines total
```

---

## üìä **Performance Optimization Integration**

### **Chi Router Benefits**
- **Radix tree routing**: O(log n) vs O(n) route matching
- **Context-based parameters**: Efficient parameter extraction
- **Built-in optimizations**: Request pooling, efficient middleware chain

### **Additional Optimizations**
```go
// Fast host extraction (from original plan)
func extractHostFast(hostHeader string) string {
    if colonIndex := strings.IndexByte(hostHeader, ':'); colonIndex != -1 {
        return hostHeader[:colonIndex]
    }
    return hostHeader
}

// Optimized transport (integrated with middleware)
var optimizedTransport = &http.Transport{
    MaxIdleConns:        100,
    MaxIdleConnsPerHost: 10,
    IdleConnTimeout:     90 * time.Second,
    WriteBufferSize:     32 * 1024,
    ReadBufferSize:      32 * 1024,
}
```

---

## üß™ **Testing Strategy**

### **1. Backward Compatibility Testing**
```bash
# Ensure all existing routing scenarios work
./test-routing.sh

# Test with existing configuration files
./keystone-gateway -config configs/host-routing-test.yaml
```

### **2. Performance Benchmarking**
```bash
# Before and after performance comparison
ab -n 10000 -c 50 http://localhost:8080/api/test

# Expected results:
# Before: ~159 req/sec
# After:  ~300+ req/sec (+89% improvement)
```

### **3. Chi-Specific Testing**
```go
func TestChiRouting(t *testing.T) {
    cfg := &Config{
        Tenants: []Tenant{
            {
                Name: "test-tenant",
                Domains: []string{"test.example.com"},
                Services: []Service{{URL: "http://backend:8080"}},
            },
        },
    }
    
    router := createRouter(cfg)
    
    req := httptest.NewRequest("GET", "/test", nil)
    req.Host = "test.example.com"
    w := httptest.NewRecorder()
    
    router.ServeHTTP(w, req)
    
    // Verify routing works correctly
}
```

---

## üìÅ **File Structure (Still Single File)**
```
main.go (300 lines total)
‚îú‚îÄ‚îÄ Imports & Types                   (40 lines)
‚îú‚îÄ‚îÄ Configuration Functions           (30 lines)
‚îú‚îÄ‚îÄ Router Setup Functions           (50 lines) ‚Üê New Chi integration
‚îú‚îÄ‚îÄ Middleware Functions             (60 lines) ‚Üê New middleware layer
‚îú‚îÄ‚îÄ Proxy Functions                  (40 lines) ‚Üê Enhanced proxy logic
‚îú‚îÄ‚îÄ Health Check Functions           (30 lines)
‚îú‚îÄ‚îÄ Utility Functions               (30 lines)
‚îú‚îÄ‚îÄ Main Function                   (20 lines) ‚Üê Simplified with Chi
```

---

## ‚úÖ **Implementation Checklist**

### **Week 1: Foundation**
- [ ] Add Chi dependency to go.mod
- [ ] Create router setup functions
- [ ] Implement basic middleware (Host matching, Proxy)
- [ ] Convert main() to use Chi router
- [ ] Test basic routing functionality

### **Week 2: Enhancement**
- [ ] Implement hybrid routing logic
- [ ] Add performance middleware (transport optimization)
- [ ] Enhanced proxy configuration
- [ ] Comprehensive testing
- [ ] Performance benchmarking
- [ ] Documentation updates

---

## üéØ **Success Criteria**

### **Performance**
- ‚úÖ +100-150% throughput improvement (159 ‚Üí 300+ req/sec)
- ‚úÖ Reduced latency (<4ms from 6.3ms)
- ‚úÖ Maintain low memory footprint

### **Architecture**
- ‚úÖ Clean middleware-based architecture
- ‚úÖ Declarative routing configuration
- ‚úÖ Professional API design patterns
- ‚úÖ Easy to extend and maintain

### **Compatibility**
- ‚úÖ 100% backward compatibility
- ‚úÖ All existing YAML configs work unchanged
- ‚úÖ Same deployment model (single binary)
- ‚úÖ Same operational simplicity

---

## üöÄ **Expected Results**

### **Immediate Benefits (v1.2.1)**
- **Performance**: 159 ‚Üí 300+ req/sec (+89% improvement)
- **Architecture**: Professional middleware-based design
- **Maintainability**: Much cleaner, organized code
- **Foundation**: Ready for v1.2.2 advanced features

### **Future Capabilities Enabled**
- **v1.2.2**: Easy middleware addition (compression, caching, metrics)
- **v1.2.3**: Advanced routing (wildcards, regex patterns)
- **v1.3.0**: Full-featured proxy with minimal complexity

---

*This enhanced v1.2.1 plan provides a quantum leap in both performance and architecture while maintaining Keystone's core philosophy of simplicity. The Chi router gives us professional-grade capabilities without sacrificing our lightweight approach.*
