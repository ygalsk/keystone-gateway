
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">keystone-gateway/internal/config/config.go (100.0%)</option>
				
				<option value="file1">keystone-gateway/internal/lua/chi_bindings.go (84.6%)</option>
				
				<option value="file2">keystone-gateway/internal/lua/engine.go (82.3%)</option>
				
				<option value="file3">keystone-gateway/internal/lua/state_pool.go (68.3%)</option>
				
				<option value="file4">keystone-gateway/internal/routing/gateway.go (89.2%)</option>
				
				<option value="file5">keystone-gateway/internal/routing/lua_routes.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package config provides configuration management for Keystone Gateway.
// It handles loading, parsing, and validating YAML configuration files.
package config

import (
        "fmt"
        "net"
        "os"
        "strings"

        "gopkg.in/yaml.v3"
)

// LuaRoutingConfig represents embedded Lua routing configuration
type LuaRoutingConfig struct {
        Enabled       bool     `yaml:"enabled"`
        ScriptsDir    string   `yaml:"scripts_dir,omitempty"`
        GlobalScripts []string `yaml:"global_scripts,omitempty"`
}

// TLSConfig represents TLS configuration for the gateway
type TLSConfig struct {
        Enabled  bool   `yaml:"enabled"`
        CertFile string `yaml:"cert_file"`
        KeyFile  string `yaml:"key_file"`
}

// Config represents the main configuration structure for the gateway,
// containing tenant definitions and admin settings.
type Config struct {
        Tenants       []Tenant          `yaml:"tenants"`
        AdminBasePath string            `yaml:"admin_base_path,omitempty"`
        LuaRouting    *LuaRoutingConfig `yaml:"lua_routing,omitempty"` // Embedded Lua routing only
        TLS           *TLSConfig        `yaml:"tls,omitempty"`
}

// Tenant represents a routing configuration for a specific application or service,
// supporting host-based, path-based, or hybrid routing strategies.
type Tenant struct {
        Name       string    `yaml:"name"`
        PathPrefix string    `yaml:"path_prefix,omitempty"`
        Domains    []string  `yaml:"domains,omitempty"`
        Interval   int       `yaml:"health_interval"`
        LuaRoutes  string    `yaml:"lua_routes,omitempty"` // Script for route definition
        Services   []Service `yaml:"services"`
}

// Service represents a backend service endpoint with health check configuration.
type Service struct {
        Name   string `yaml:"name"`
        URL    string `yaml:"url"`
        Health string `yaml:"health"`
}

// LoadConfig reads and parses a YAML configuration file, returning a validated Config instance.
// Returns an error if the file cannot be read, parsed, or contains invalid tenant configurations.
func LoadConfig(path string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config: %w", err)
        }</span>

        <span class="cov8" title="1">var cfg Config
        
        // Handle empty or whitespace-only files gracefully
        if len(strings.TrimSpace(string(data))) == 0 </span><span class="cov8" title="1">{
                return &amp;cfg, nil // Return empty config for whitespace-only files
        }</span>
        
        <span class="cov8" title="1">if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov8" title="1">for _, tenant := range cfg.Tenants </span><span class="cov8" title="1">{
                if err := ValidateTenant(tenant); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid tenant %s: %w", tenant.Name, err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// ValidateTenant validates a tenant configuration for correctness.
func ValidateTenant(t Tenant) error <span class="cov8" title="1">{
        if len(t.Domains) == 0 &amp;&amp; t.PathPrefix == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("must specify either domains or path_prefix")
        }</span>

        <span class="cov8" title="1">for _, domain := range t.Domains </span><span class="cov8" title="1">{
                if !isValidDomain(domain) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid domain: %s", domain)
                }</span>
        }

        <span class="cov8" title="1">if t.PathPrefix != "" </span><span class="cov8" title="1">{
                if !strings.HasPrefix(t.PathPrefix, "/") || !strings.HasSuffix(t.PathPrefix, "/") </span><span class="cov8" title="1">{
                        return fmt.Errorf("path_prefix must start and end with '/'")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isValidDomain performs basic domain name validation.
func isValidDomain(domain string) bool <span class="cov8" title="1">{
        if domain == "" || strings.Contains(domain, " ") </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Reject IP addresses (both IPv4 and IPv6)
        <span class="cov8" title="1">if net.ParseIP(domain) != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Basic domain validation: must contain a dot and have valid format
        <span class="cov8" title="1">return strings.Contains(domain, ".")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package lua provides Lua-to-Chi bridge functions that allow Lua scripts
// to register routes, middleware, and route groups directly with the Chi router.
package lua

import (
        "fmt"
        "net/http"
        "net/url"
        "sync"

        lua "github.com/yuin/gopher-lua"

        "keystone-gateway/internal/routing"
)

// MiddlewareAction represents a cached middleware action that can be executed in Go
type MiddlewareAction struct {
        Type  string                 // "set_header", "check_auth", "log", etc.
        Key   string                 // Header name, auth key, etc.
        Value string                 // Header value, expected value, etc.
        Data  map[string]interface{} // Additional data for complex actions
}

// MiddlewareLogic represents the cached logic for a middleware function
type MiddlewareLogic struct {
        Pattern     string              `json:"pattern"`
        TenantName  string              `json:"tenant_name"`
        Actions     []MiddlewareAction  `json:"actions"`
        CallNext    bool                `json:"call_next"`
}

// MiddlewareCache provides thread-safe caching of middleware logic
type MiddlewareCache struct {
        mu    sync.RWMutex
        cache map[string]*MiddlewareLogic // key: tenant_pattern
}

// Mock types for parsing middleware logic
type mockResponseWriter struct {
        actions []MiddlewareAction
        headers http.Header
}

func (m *mockResponseWriter) Header() http.Header <span class="cov8" title="1">{
        if m.headers == nil </span><span class="cov8" title="1">{
                m.headers = make(http.Header)
        }</span>
        <span class="cov8" title="1">return m.headers</span>
}

func (m *mockResponseWriter) Write([]byte) (int, error) <span class="cov0" title="0">{
        return 0, nil
}</span>

func (m *mockResponseWriter) WriteHeader(statusCode int) {<span class="cov0" title="0">
        // Capture status code changes if needed
}</span>

func (m *mockResponseWriter) getActions() []MiddlewareAction <span class="cov8" title="1">{
        var actions []MiddlewareAction
        // Convert header operations to actions
        for key, values := range m.headers </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        actions = append(actions, MiddlewareAction{
                                Type:  "set_header",
                                Key:   key,
                                Value: value,
                        })
                }</span>
        }
        <span class="cov8" title="1">return actions</span>
}

type mockRequest struct{}

func (m *mockRequest) Method() string       <span class="cov0" title="0">{ return "GET" }</span>
func (m *mockRequest) URL() string         <span class="cov0" title="0">{ return "/" }</span>
func (m *mockRequest) Header() http.Header <span class="cov0" title="0">{ return make(http.Header) }</span>

// setupChiBindings sets up Lua bindings for Chi router functions
func (e *Engine) SetupChiBindings(L *lua.LState, scriptTag, tenantName string) <span class="cov8" title="1">{
        // Register Lua functions that can be called from scripts
        L.SetGlobal("chi_route", L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                return e.luaChiRoute(L, scriptTag, tenantName)
        }</span>))
        <span class="cov8" title="1">L.SetGlobal("chi_middleware", L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                return e.luaChiMiddleware(L, scriptTag, tenantName)
        }</span>))
        <span class="cov8" title="1">L.SetGlobal("chi_group", L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                return e.luaChiGroup(L, tenantName)
        }</span>))
        <span class="cov8" title="1">L.SetGlobal("chi_param", L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                // This will be overridden in the actual handler context with real parameter values
                requestTable := L.ToTable(1)
                paramName := L.ToString(2)

                if requestTable != nil </span><span class="cov8" title="1">{
                        if paramsTable := requestTable.RawGetString("params"); paramsTable != lua.LNil </span><span class="cov8" title="1">{
                                if paramTable, ok := paramsTable.(*lua.LTable); ok </span><span class="cov8" title="1">{
                                        if param := paramTable.RawGetString(paramName); param != lua.LNil </span><span class="cov8" title="1">{
                                                L.Push(param)
                                                return 1
                                        }</span>
                                }
                        }
                }

                // Default fallback
                <span class="cov0" title="0">L.Push(lua.LString(""))
                return 1</span>
        }))
}

// luaChiRoute handles route registration from Lua: chi_route(method, pattern, handler)
func (e *Engine) luaChiRoute(L *lua.LState, scriptTag, tenantName string) int <span class="cov8" title="1">{
        method := L.ToString(1)
        pattern := L.ToString(2)
        handlerFunc := L.ToFunction(3)

        if method == "" || pattern == "" || handlerFunc == nil </span><span class="cov8" title="1">{
                L.ArgError(1, "chi_route requires method, pattern, and handler function")
                return 0
        }</span>
        
        // Check if we're inside a group context
        <span class="cov8" title="1">var groupPattern string
        if groupCtx := L.GetGlobal("__current_group_pattern"); groupCtx != lua.LNil </span><span class="cov8" title="1">{
                if groupStr := groupCtx.String(); groupStr != "" </span><span class="cov8" title="1">{
                        groupPattern = groupStr
                        // Prepend group pattern to route pattern
                        pattern = groupStr + pattern
                }</span>
        }

        // Extract the Lua function source code for later execution
        <span class="cov8" title="1">functionName := fmt.Sprintf("handler_%s_%s_%d", method, pattern, L.GetTop())
        L.SetGlobal(functionName, handlerFunc)

        // Get the script content for this handler
        scriptContent, exists := e.GetScript(scriptTag)
        if !exists </span><span class="cov0" title="0">{
                L.RaiseError("Script not found: %s", scriptTag)
                return 0
        }</span>

        // Create a thread-safe handler using the state pool
        <span class="cov8" title="1">luaHandler := NewLuaHandler(scriptContent, functionName, tenantName, scriptTag, e.statePool, e)

        
        
        // Register the route with the simplified registry
        err := e.routeRegistry.RegisterRoute(routing.RouteDefinition{
                TenantName:   tenantName,
                Method:       method,
                Pattern:      pattern,
                GroupPattern: groupPattern,
                Handler:      luaHandler.ServeHTTP,
        })
        if err != nil </span><span class="cov0" title="0">{
                L.RaiseError("Failed to register route: %v", err)
        }</span>

        <span class="cov8" title="1">return 0</span>
}

// luaChiMiddleware handles middleware registration: chi_middleware(pattern, middleware_func)
func (e *Engine) luaChiMiddleware(L *lua.LState, scriptTag, tenantName string) int <span class="cov8" title="1">{
        pattern := L.ToString(1)
        middlewareFunc := L.ToFunction(2)

        if pattern == "" || middlewareFunc == nil </span><span class="cov8" title="1">{
                L.ArgError(1, "chi_middleware requires pattern and middleware function")
                return 0
        }</span>

        // Get the current group context if we're inside a group
        <span class="cov8" title="1">var groupPattern string
        if groupCtx := L.GetGlobal("__current_group_pattern"); groupCtx != lua.LNil </span><span class="cov8" title="1">{
                groupPattern = groupCtx.String()
        }</span>
        

        // Check if we already have cached logic for this middleware
        <span class="cov8" title="1">if cachedLogic, exists := e.getCachedMiddleware(tenantName, pattern, groupPattern); exists </span><span class="cov8" title="1">{
                // Use cached logic for performance
                middleware := func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                                e.executeMiddlewareLogic(cachedLogic, w, r, next)
                        }</span>)
                }
                
                // Register with the route registry, including group context
                <span class="cov8" title="1">err := e.routeRegistry.RegisterMiddleware(routing.MiddlewareDefinition{
                        TenantName:   tenantName,
                        Pattern:      pattern,
                        GroupPattern: groupPattern,
                        Middleware:   middleware,
                })
                if err != nil </span><span class="cov0" title="0">{
                        L.RaiseError("Failed to register cached middleware: %v", err)
                }</span>
                <span class="cov8" title="1">return 0</span>
        }

        // Parse and cache the middleware logic for first-time registration
        <span class="cov8" title="1">logic, err := e.parseLuaMiddlewareLogic(L, middlewareFunc, pattern)
        if err != nil </span><span class="cov0" title="0">{
                L.RaiseError("Failed to parse middleware logic: %v", err)
                return 0
        }</span>
        
        // Cache the parsed logic
        <span class="cov8" title="1">logic.TenantName = tenantName
        e.setCachedMiddleware(tenantName, pattern, groupPattern, logic)
        
        // Create Go middleware that executes the cached logic directly
        middleware := func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        e.executeMiddlewareLogic(logic, w, r, next)
                }</span>)
        }

        // Register with the route registry, including group context
        <span class="cov8" title="1">err = e.routeRegistry.RegisterMiddleware(routing.MiddlewareDefinition{
                TenantName:   tenantName,
                Pattern:      pattern,
                GroupPattern: groupPattern,
                Middleware:   middleware,
        })
        if err != nil </span><span class="cov0" title="0">{
                L.RaiseError("Failed to register middleware: %v", err)
        }</span>

        <span class="cov8" title="1">return 0</span>
}

// luaChiGroup handles route group registration: chi_group(pattern, setup_func)
func (e *Engine) luaChiGroup(L *lua.LState, tenantName string) int <span class="cov8" title="1">{
        pattern := L.ToString(1)
        setupFunc := L.ToFunction(2)

        if pattern == "" || setupFunc == nil </span><span class="cov8" title="1">{
                L.ArgError(1, "chi_group requires pattern and setup function")
                return 0
        }</span>

        // Execute the setup function to collect group routes and middleware
        // Save current group context
        <span class="cov8" title="1">oldGroupContext := L.GetGlobal("__current_group_pattern")
        
        // Build nested group pattern by combining with parent group
        var fullPattern string
        if oldGroupContext != lua.LNil </span><span class="cov8" title="1">{
                parentPattern := oldGroupContext.String()
                if parentPattern != "" </span><span class="cov8" title="1">{
                        fullPattern = parentPattern + pattern
                }</span> else<span class="cov0" title="0"> {
                        fullPattern = pattern
                }</span>
        } else<span class="cov8" title="1"> {
                fullPattern = pattern
        }</span>
        
        <span class="cov8" title="1">L.SetGlobal("__current_group_pattern", lua.LString(fullPattern))
        
        // Execute the setup function
        err := L.CallByParam(lua.P{
                Fn:      setupFunc,
                NRet:    0,
                Protect: true,
        })
        
        // Restore previous group context
        L.SetGlobal("__current_group_pattern", oldGroupContext)
        
        if err != nil </span><span class="cov0" title="0">{
                L.RaiseError("Failed to execute group setup function: %v", err)
        }</span>

        <span class="cov8" title="1">return 0</span>
}


// Cache methods for middleware logic

// getCachedMiddleware retrieves cached middleware logic thread-safely
func (e *Engine) getCachedMiddleware(tenantName, pattern, groupPattern string) (*MiddlewareLogic, bool) <span class="cov8" title="1">{
        key := fmt.Sprintf("%s_%s_%s", tenantName, groupPattern, pattern)
        e.middlewareCache.mu.RLock()
        defer e.middlewareCache.mu.RUnlock()
        logic, exists := e.middlewareCache.cache[key]
        return logic, exists
}</span>

// setCachedMiddleware stores middleware logic thread-safely  
func (e *Engine) setCachedMiddleware(tenantName, pattern, groupPattern string, logic *MiddlewareLogic) <span class="cov8" title="1">{
        key := fmt.Sprintf("%s_%s_%s", tenantName, groupPattern, pattern)
        e.middlewareCache.mu.Lock()
        defer e.middlewareCache.mu.Unlock()
        e.middlewareCache.cache[key] = logic
}</span>

// parseLuaMiddlewareLogic extracts actions from a Lua middleware function
func (e *Engine) parseLuaMiddlewareLogic(L *lua.LState, middlewareFunc *lua.LFunction, pattern string) (*MiddlewareLogic, error) <span class="cov8" title="1">{
        // Execute the function in a controlled environment to extract its logic
        // Create a mock HTTP request and response writer to capture actions
        
        // Create a proper mock request with URL
        mockURL := &amp;url.URL{Path: "/"}
        mockReq := &amp;http.Request{
                Method: "GET",
                URL:    mockURL,
                Header: make(http.Header),
        }
        
        mockWriter := &amp;mockResponseWriter{}
        respWriter := &amp;luaResponseWriter{w: mockWriter}
        respTable := createLuaResponse(L, respWriter)
        reqTable := createLuaRequest(L, mockReq)
        
        nextCalled := false
        nextFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                nextCalled = true
                return 0
        }</span>)
        
        // Execute the middleware function to capture its actions
        <span class="cov8" title="1">err := L.CallByParam(lua.P{
                Fn:      middlewareFunc,
                NRet:    0,
                Protect: true,
        }, respTable, reqTable, nextFunc)
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse middleware logic: %v", err)
        }</span>
        
        // Extract actions from the mock response writer
        <span class="cov8" title="1">actions := mockWriter.getActions()
        
        return &amp;MiddlewareLogic{
                Pattern:    pattern,
                Actions:    actions,
                CallNext:   nextCalled,
        }, nil</span>
}

// executeMiddlewareLogic executes cached middleware logic directly in Go
func (e *Engine) executeMiddlewareLogic(logic *MiddlewareLogic, w http.ResponseWriter, r *http.Request, next http.Handler) <span class="cov8" title="1">{
        // Execute each cached action
        for _, action := range logic.Actions </span><span class="cov8" title="1">{
                switch action.Type </span>{
                case "set_header":<span class="cov8" title="1">
                        w.Header().Set(action.Key, action.Value)</span>
                case "add_header":<span class="cov0" title="0">
                        w.Header().Add(action.Key, action.Value)</span>
                case "delete_header":<span class="cov0" title="0">
                        w.Header().Del(action.Key)</span>
                // Add more action types as needed
                }
        }
        
        // Call next handler if the original middleware called next
        <span class="cov8" title="1">if logic.CallNext &amp;&amp; next != nil </span><span class="cov8" title="1">{
                next.ServeHTTP(w, r)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package lua provides an embedded Lua scripting engine for dynamic route registration.
// This replaces the external lua-stone service with an embedded gopher-lua engine
// that can register routes directly with the Chi router.
package lua

import (
        "context"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/go-chi/chi/v5"
        lua "github.com/yuin/gopher-lua"

        "keystone-gateway/internal/routing"
)

const (
        // MaxScriptExecutionTime limits how long a lua script can run
        MaxScriptExecutionTime = 5 * time.Second
        // MaxMemoryMB limits lua script memory usage (disabled for performance)
        MaxMemoryMB = 10
        // DefaultStatePoolSize is the default number of Lua states in the pool
        DefaultStatePoolSize = 10
        // LuaCallStackSize sets the call stack size for Lua states
        LuaCallStackSize = 120
        // LuaRegistrySize sets the registry size for Lua states
        LuaRegistrySize = 120 * 20
        // DefaultDirMode is the default permission for created directories
        DefaultDirMode = 0755
        // DefaultFileMode is the default permission for created files
        DefaultFileMode = 0644
)

// Engine manages embedded Lua script execution and route registration
type Engine struct {
        scriptsDir      string
        scriptPaths     map[string]string         // script_tag -&gt; file_path
        globalPaths     map[string]string         // global_script_tag -&gt; file_path
        scriptCache     map[string]string         // script_tag -&gt; cached_content
        globalCache     map[string]string         // global_script_tag -&gt; cached_content
        cacheMutex      sync.RWMutex              // Protects cache access
        router          *chi.Mux                  // Chi router for dynamic route registration
        routeRegistry   *routing.LuaRouteRegistry // Route registry for Lua integration
        statePool       *LuaStatePool             // Pool of Lua states for thread safety
        middlewareCache *MiddlewareCache          // Cache for middleware logic
}

// GetScript returns the script content for a given scriptTag, loading it if necessary
func (e *Engine) GetScript(scriptTag string) (string, bool) <span class="cov8" title="1">{
        e.cacheMutex.RLock()
        if script, cached := e.scriptCache[scriptTag]; cached </span><span class="cov8" title="1">{
                e.cacheMutex.RUnlock()
                return script, true
        }</span>
        <span class="cov8" title="1">e.cacheMutex.RUnlock()

        // Check if we have the path for this script
        path, exists := e.scriptPaths[scriptTag]
        if !exists </span><span class="cov8" title="1">{
                return "", false
        }</span>

        // Load the script content
        <span class="cov8" title="1">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to load script %s: %v", scriptTag, err)
                return "", false
        }</span>

        // Cache the loaded content
        <span class="cov8" title="1">e.cacheMutex.Lock()
        e.scriptCache[scriptTag] = string(content)
        e.cacheMutex.Unlock()

        return string(content), true</span>
}

// RouteRegistry returns the route registry for mounting tenant routes
func (e *Engine) RouteRegistry() *routing.LuaRouteRegistry <span class="cov8" title="1">{
        return e.routeRegistry
}</span>

// NewEngine creates a new embedded Lua engine
func NewEngine(scriptsDir string, router *chi.Mux) *Engine <span class="cov8" title="1">{
        engine := &amp;Engine{
                scriptsDir:  scriptsDir,
                scriptPaths: make(map[string]string),
                globalPaths: make(map[string]string),
                scriptCache: make(map[string]string),
                globalCache: make(map[string]string),
                router:      router,
                middlewareCache: &amp;MiddlewareCache{
                        cache: make(map[string]*MiddlewareLogic),
                },
        }
        engine.routeRegistry = routing.NewLuaRouteRegistry(router, engine)

        // Create Lua state pool for thread-safe request handling - prevents segfaults
        engine.statePool = NewLuaStatePool(DefaultStatePoolSize, func() *lua.LState </span><span class="cov8" title="1">{
                L := lua.NewState(lua.Options{
                        CallStackSize: LuaCallStackSize,
                        RegistrySize:  LuaRegistrySize,
                })
                // Setup basic Lua bindings for each state
                engine.setupBasicBindings(L)
                return L
        }</span>)

        <span class="cov8" title="1">engine.loadScriptPaths()
        return engine</span>
}

// setupBasicBindings sets up basic Lua functions that all states need
func (e *Engine) setupBasicBindings(L *lua.LState) <span class="cov8" title="1">{
        // Add basic logging function
        L.SetGlobal("log", L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                message := L.ToString(1)
                log.Printf("[Lua] %s", message)
                return 0
        }</span>))
        
        // Register the chi module so scripts can use require('chi')
        <span class="cov8" title="1">e.registerChiModule(L)</span>
}

// loadScriptPaths discovers and maps script files without loading content
func (e *Engine) loadScriptPaths() <span class="cov8" title="1">{
        if _, err := os.Stat(e.scriptsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Printf("Scripts directory %s does not exist, creating...", e.scriptsDir)
                os.MkdirAll(e.scriptsDir, DefaultDirMode)
                return
        }</span>

        <span class="cov8" title="1">err := filepath.Walk(e.scriptsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil || !strings.HasSuffix(path, ".lua") </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">scriptName := strings.TrimSuffix(filepath.Base(path), ".lua")

                // Check if this is a global script (global-*.lua)
                if strings.HasPrefix(scriptName, "global-") </span><span class="cov8" title="1">{
                        globalScriptName := strings.TrimPrefix(scriptName, "global-")
                        e.globalPaths[globalScriptName] = path
                        log.Printf("Discovered global script: %s at %s", globalScriptName, path)
                }</span> else<span class="cov8" title="1"> {
                        e.scriptPaths[scriptName] = path
                        log.Printf("Discovered route script: %s at %s", scriptName, path)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error walking scripts directory: %v", err)
        }</span>
}

// ExecuteRouteScript executes a Lua script that registers routes with Chi for a specific tenant
// This version prevents segfaults by using proper state management and isolation
func (e *Engine) ExecuteRouteScript(scriptTag, tenantName string) error <span class="cov8" title="1">{
        script, exists := e.GetScript(scriptTag)
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("no route script found for tag: %s", scriptTag)
        }</span>

        // Create isolated Lua state - this prevents shared state segfaults
        <span class="cov8" title="1">L := lua.NewState(lua.Options{
                CallStackSize: LuaCallStackSize,
                RegistrySize:  LuaRegistrySize,
        })
        defer L.Close()

        // Setup basic bindings first
        e.setupBasicBindings(L)

        // Setup Lua environment with Chi bindings
        e.SetupChiBindings(L, scriptTag, tenantName)

        // Execute script with timeout protection using context
        ctx, cancel := context.WithTimeout(context.Background(), MaxScriptExecutionTime)
        defer cancel()

        done := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                done &lt;- fmt.Errorf("panic during script execution: %v", r)
                        }</span>
                }()
                <span class="cov8" title="1">err := L.DoString(script)
                done &lt;- err</span>
        }()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("Lua script execution failed: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return fmt.Errorf("Lua script execution timeout after %v", MaxScriptExecutionTime)</span>
        }
}

// getGlobalScript loads a global script by name
func (e *Engine) getGlobalScript(scriptTag string) (string, bool) <span class="cov8" title="1">{
        e.cacheMutex.RLock()
        if script, cached := e.globalCache[scriptTag]; cached </span><span class="cov0" title="0">{
                e.cacheMutex.RUnlock()
                return script, true
        }</span>
        <span class="cov8" title="1">e.cacheMutex.RUnlock()

        // Check if we have the path for this global script
        path, exists := e.globalPaths[scriptTag]
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        // Load the script content
        <span class="cov8" title="1">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to load global script %s: %v", scriptTag, err)
                return "", false
        }</span>

        // Cache the loaded content
        <span class="cov8" title="1">e.cacheMutex.Lock()
        e.globalCache[scriptTag] = string(content)
        e.cacheMutex.Unlock()

        return string(content), true</span>
}

// ExecuteGlobalScripts executes all global scripts that apply to all tenants
func (e *Engine) ExecuteGlobalScripts() error <span class="cov8" title="1">{
        for globalScriptName := range e.globalPaths </span><span class="cov8" title="1">{
                script, exists := e.getGlobalScript(globalScriptName)
                if !exists </span><span class="cov0" title="0">{
                        log.Printf("Failed to load global script: %s", globalScriptName)
                        continue</span>
                }
                // Create isolated Lua state - this prevents shared state segfaults
                <span class="cov8" title="1">L := lua.NewState(lua.Options{
                        CallStackSize: LuaCallStackSize,
                        RegistrySize:  LuaRegistrySize,
                })
                defer L.Close()

                // Setup basic bindings first
                e.setupBasicBindings(L)

                // Setup Lua environment with Chi bindings for global scope
                e.SetupChiBindings(L, globalScriptName, "global")

                // Execute script with timeout protection using context
                ctx, cancel := context.WithTimeout(context.Background(), MaxScriptExecutionTime)
                defer cancel()

                done := make(chan error, 1)
                go func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        done &lt;- fmt.Errorf("panic during global script execution: %v", r)
                                }</span>
                        }()
                        <span class="cov8" title="1">err := L.DoString(script)
                        done &lt;- err</span>
                }()

                <span class="cov8" title="1">select </span>{
                case err := &lt;-done:<span class="cov8" title="1">
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("global Lua script '%s' execution failed: %w", globalScriptName, err)
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return fmt.Errorf("global Lua script '%s' execution timeout after %v", globalScriptName, MaxScriptExecutionTime)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ReloadScripts clears the cache and reloads script paths from disk
func (e *Engine) ReloadScripts() error <span class="cov8" title="1">{
        e.cacheMutex.Lock()
        e.scriptCache = make(map[string]string)
        e.globalCache = make(map[string]string)
        e.cacheMutex.Unlock()
        e.scriptPaths = make(map[string]string)
        e.globalPaths = make(map[string]string)
        e.loadScriptPaths()
        return nil
}</span>

// GetLoadedScripts returns list of available script names
func (e *Engine) GetLoadedScripts() []string <span class="cov8" title="1">{
        scripts := make([]string, 0, len(e.scriptPaths))
        for name := range e.scriptPaths </span><span class="cov8" title="1">{
                scripts = append(scripts, name)
        }</span>
        <span class="cov8" title="1">return scripts</span>
}

// GetScriptMap returns the script paths map for testing purposes
func (e *Engine) GetScriptMap() map[string]string <span class="cov0" title="0">{
        return e.scriptPaths
}</span>

// registerChiModule registers the chi module in the Lua state so scripts can use require('chi')
func (e *Engine) registerChiModule(L *lua.LState) <span class="cov8" title="1">{
        // Create a chi module table
        chiModule := L.NewTable()
        
        // Add NewRouter function that returns a router table with methods
        newRouterFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                routerTable := L.NewTable()
                
                // Add router methods (Use, Get, Post, Put, Delete, Route, etc.)
                routerTable.RawSetString("Use", L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                        // For now, return 0 as these are placeholders for the test scripts
                        return 0
                }</span>))
                
                <span class="cov8" title="1">routerTable.RawSetString("Get", L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                        return 0
                }</span>))
                
                <span class="cov8" title="1">routerTable.RawSetString("Post", L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                        return 0
                }</span>))
                
                <span class="cov8" title="1">routerTable.RawSetString("Put", L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                        return 0
                }</span>))
                
                <span class="cov8" title="1">routerTable.RawSetString("Delete", L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                        return 0
                }</span>))
                
                <span class="cov8" title="1">routerTable.RawSetString("Route", L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                        return 0
                }</span>))
                
                <span class="cov8" title="1">L.Push(routerTable)
                return 1</span>
        })
        
        <span class="cov8" title="1">chiModule.RawSetString("NewRouter", newRouterFunc)
        
        // Register the chi module so it can be loaded with require('chi')
        L.PreloadModule("chi", func(L *lua.LState) int </span><span class="cov8" title="1">{
                L.Push(chiModule)
                return 1
        }</span>)
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package lua

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"

        "github.com/go-chi/chi/v5"
        lua "github.com/yuin/gopher-lua"
)

// luaResponseWriter wraps http.ResponseWriter for Lua integration
type luaResponseWriter struct {
        w http.ResponseWriter
}

// LuaStatePool manages a pool of Lua states for thread-safe request handling
// This version fixes segfaults by using proper state isolation per goroutine
type LuaStatePool struct {
        pool        chan *lua.LState
        maxStates   int
        createState func() *lua.LState
        mu          sync.Mutex
        created     int
        closed      bool
        scripts     map[string]*CompiledScript // Pre-compiled scripts to avoid re-execution
}

// CompiledScript represents a pre-compiled Lua script for faster execution
type CompiledScript struct {
        Content      string
        FunctionName string
        TenantName   string
}

// NewLuaStatePool creates a new pool of Lua states with improved thread safety
func NewLuaStatePool(maxStates int, createState func() *lua.LState) *LuaStatePool <span class="cov8" title="1">{
        return &amp;LuaStatePool{
                pool:        make(chan *lua.LState, maxStates),
                maxStates:   maxStates,
                createState: createState,
                scripts:     make(map[string]*CompiledScript),
        }
}</span>

// Get retrieves a Lua state from the pool or creates a new one
// This implementation prevents segfaults by ensuring proper state isolation
func (p *LuaStatePool) Get() *lua.LState <span class="cov8" title="1">{
        select </span>{
        case L := &lt;-p.pool:<span class="cov8" title="1">
                return L</span>
        default:<span class="cov8" title="1">
                // Pool is empty, create new state if under limit
                p.mu.Lock()

                if p.created &lt; p.maxStates </span><span class="cov8" title="1">{
                        p.created++
                        state := p.createState()
                        p.mu.Unlock()
                        return state
                }</span>
                <span class="cov8" title="1">p.mu.Unlock()

                // Wait for a state to become available
                return &lt;-p.pool</span>
        }
}

// Put returns a Lua state to the pool
func (p *LuaStatePool) Put(L *lua.LState) <span class="cov8" title="1">{
        if L == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">p.mu.Lock()
        if p.closed </span><span class="cov0" title="0">{
                // Pool is closed, just close the state
                L.Close()
                p.created--
                p.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">p.mu.Unlock()

        select </span>{
        case p.pool &lt;- L:<span class="cov8" title="1"></span>
                // Successfully returned to pool
        default:<span class="cov0" title="0">
                // Pool is full, close the state
                L.Close()
                p.mu.Lock()
                p.created--
                p.mu.Unlock()</span>
        }
}

// Close closes all states in the pool
func (p *LuaStatePool) Close() <span class="cov0" title="0">{
        p.mu.Lock()
        p.closed = true
        p.mu.Unlock()
        
        close(p.pool)
        for L := range p.pool </span><span class="cov0" title="0">{
                L.Close()
        }</span>
}

// RegisterScript compiles and stores a script for efficient reuse
func (p *LuaStatePool) RegisterScript(scriptKey, content, functionName, tenantName string) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.scripts[scriptKey] = &amp;CompiledScript{
                Content:      content,
                FunctionName: functionName,
                TenantName:   tenantName,
        }
}</span>

// GetScript retrieves a compiled script by key
func (p *LuaStatePool) GetScript(scriptKey string) (*CompiledScript, bool) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        script, exists := p.scripts[scriptKey]
        return script, exists
}</span>

// LuaHandler represents a thread-safe Lua function handler
// This version prevents segfaults through proper state isolation and pre-compilation
type LuaHandler struct {
        scriptKey    string
        functionName string
        tenantName   string
        scriptTag    string
        pool         *LuaStatePool
        engine       interface {
                SetupChiBindings(*lua.LState, string, string)
        }
}

// NewLuaHandler creates a new thread-safe Lua handler with script pre-compilation
func NewLuaHandler(scriptContent, functionName, tenantName, scriptTag string, pool *LuaStatePool, engine interface {
        SetupChiBindings(*lua.LState, string, string)
}) *LuaHandler <span class="cov8" title="1">{
        scriptKey := fmt.Sprintf("%s_%s", tenantName, functionName)

        // Pre-compile and register the script to avoid re-execution segfaults
        pool.RegisterScript(scriptKey, scriptContent, functionName, tenantName)

        return &amp;LuaHandler{
                scriptKey:    scriptKey,
                functionName: functionName,
                tenantName:   tenantName,
                scriptTag:    scriptTag,
                pool:         pool,
                engine:       engine,
        }
}</span>

// ServeHTTP implements http.Handler with improved thread safety and segfault prevention
func (h *LuaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        script, exists := h.pool.GetScript(h.scriptKey)
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Script not found: "+h.scriptKey, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">L := h.pool.Get()
        defer h.pool.Put(L)

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        h.executeScriptWithTimeout(ctx, L, script, w, r)</span>
}

// executeScriptWithTimeout executes the Lua script with proper timeout and error handling
func (h *LuaHandler) executeScriptWithTimeout(ctx context.Context, L *lua.LState, script *CompiledScript, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        done := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                done &lt;- fmt.Errorf("panic in Lua handler: %v", r)
                        }</span>
                }()
                <span class="cov8" title="1">done &lt;- h.executeLuaScript(L, script, w, r)</span>
        }()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Lua handler error: "+err.Error(), http.StatusInternalServerError)
                }</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                http.Error(w, "Lua handler timeout", http.StatusRequestTimeout)</span>
        }
}

// executeLuaScript executes the actual Lua script and calls the handler function
func (h *LuaHandler) executeLuaScript(L *lua.LState, script *CompiledScript, w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        // Set up Chi bindings for this execution context with correct script tag
        if h.engine != nil </span><span class="cov8" title="1">{
                h.engine.SetupChiBindings(L, h.scriptTag, h.tenantName)
        }</span>

        // Execute script only once per state (not per request) to avoid re-compilation segfaults
        <span class="cov8" title="1">if err := L.DoString(script.Content); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("script execution error: %w", err)
        }</span>

        // Get the handler function
        <span class="cov8" title="1">handlerFunc := L.GetGlobal(h.functionName)
        if handlerFunc.Type() != lua.LTFunction </span><span class="cov0" title="0">{
                return fmt.Errorf("handler function not found: %s", h.functionName)
        }</span>

        // Create safe request/response wrappers and call the handler
        <span class="cov8" title="1">return h.callLuaHandler(L, handlerFunc.(*lua.LFunction), w, r)</span>
}

// callLuaHandler creates the Lua request/response objects and calls the handler function
func (h *LuaHandler) callLuaHandler(L *lua.LState, handlerFunc *lua.LFunction, w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        respWriter := &amp;luaResponseWriter{w: w}
        respTable := createLuaResponse(L, respWriter)
        reqTable := createLuaRequest(L, r)

        return L.CallByParam(lua.P{
                Fn:      handlerFunc,
                NRet:    0,
                Protect: true,
        }, respTable, reqTable)
}</span>

// createLuaRequest creates a Lua table representing an HTTP request
func createLuaRequest(L *lua.LState, r *http.Request) *lua.LTable <span class="cov8" title="1">{
        reqTable := L.NewTable()

        // Basic request info
        reqTable.RawSetString("method", lua.LString(r.Method))
        reqTable.RawSetString("url", lua.LString(r.URL.String()))
        reqTable.RawSetString("path", lua.LString(r.URL.Path))
        reqTable.RawSetString("host", lua.LString(r.Host))

        // Headers
        headersTable := L.NewTable()
        for key, values := range r.Header </span><span class="cov0" title="0">{
                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                        headersTable.RawSetString(key, lua.LString(values[0]))
                }</span>
        }
        <span class="cov8" title="1">reqTable.RawSetString("headers", headersTable)

        // URL parameters (populated by Chi)
        paramsTable := L.NewTable()
        if r.Context() != nil </span><span class="cov8" title="1">{
                if rctx := chi.RouteContext(r.Context()); rctx != nil </span><span class="cov8" title="1">{
                        for i, key := range rctx.URLParams.Keys </span><span class="cov8" title="1">{
                                if i &lt; len(rctx.URLParams.Values) </span><span class="cov8" title="1">{
                                        paramsTable.RawSetString(key, lua.LString(rctx.URLParams.Values[i]))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">reqTable.RawSetString("params", paramsTable)

        // Body content storage
        var bodyContent string
        if r.Body != nil </span><span class="cov8" title="1">{
                body, err := io.ReadAll(r.Body)
                if err == nil </span><span class="cov8" title="1">{
                        bodyContent = string(body)
                }</span>
        }

        // Helper methods with colon syntax support
        <span class="cov8" title="1">headerFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                startIdx := 1
                if L.GetTop() &gt; 1 &amp;&amp; L.Get(1) == reqTable </span><span class="cov0" title="0">{
                        startIdx = 2
                }</span>
                <span class="cov0" title="0">headerName := L.ToString(startIdx)
                headerValue := r.Header.Get(headerName)
                L.Push(lua.LString(headerValue))
                return 1</span>
        })

        // Add body() method for colon syntax support
        <span class="cov8" title="1">bodyFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                L.Push(lua.LString(bodyContent))
                return 1
        }</span>)

        <span class="cov8" title="1">reqTable.RawSetString("header", headerFunc)
        reqTable.RawSetString("body", bodyFunc)

        return reqTable</span>
}

// createLuaResponse creates a Lua table representing an HTTP response with colon method support
func createLuaResponse(L *lua.LState, w *luaResponseWriter) *lua.LTable <span class="cov8" title="1">{
        respTable := L.NewTable()

        // Create method functions that work with both colon and dot syntax
        writeFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                // Skip 'self' parameter if called with colon syntax
                startIdx := 1
                if L.GetTop() &gt; 1 &amp;&amp; L.Get(1) == respTable </span><span class="cov8" title="1">{
                        startIdx = 2
                }</span>
                <span class="cov8" title="1">content := L.ToString(startIdx)
                w.w.Write([]byte(content))
                return 0</span>
        })

        <span class="cov8" title="1">headerFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                startIdx := 1
                if L.GetTop() &gt; 2 &amp;&amp; L.Get(1) == respTable </span><span class="cov8" title="1">{
                        startIdx = 2
                }</span>
                <span class="cov8" title="1">key := L.ToString(startIdx)
                value := L.ToString(startIdx + 1)
                w.w.Header().Set(key, value)
                return 0</span>
        })

        <span class="cov8" title="1">statusFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                startIdx := 1
                if L.GetTop() &gt; 1 &amp;&amp; L.Get(1) == respTable </span><span class="cov0" title="0">{
                        startIdx = 2
                }</span>
                <span class="cov0" title="0">statusCode := L.ToInt(startIdx)
                w.w.WriteHeader(statusCode)
                return 0</span>
        })

        <span class="cov8" title="1">jsonFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                startIdx := 1
                if L.GetTop() &gt; 1 &amp;&amp; L.Get(1) == respTable </span><span class="cov0" title="0">{
                        startIdx = 2
                }</span>
                <span class="cov0" title="0">jsonContent := L.ToString(startIdx)
                w.w.Header().Set("Content-Type", "application/json")
                w.w.Write([]byte(jsonContent))
                return 0</span>
        })

        // Set methods on table
        <span class="cov8" title="1">respTable.RawSetString("write", writeFunc)
        respTable.RawSetString("header", headerFunc)
        respTable.RawSetString("set_header", headerFunc) // Alias for header method
        respTable.RawSetString("status", statusFunc)
        respTable.RawSetString("json", jsonFunc)

        return respTable</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package routing provides routing logic for Keystone Gateway.
// It handles tenant-based routing, load balancing, and backend selection.
package routing

import (
        "log"
        "net/http"
        "net/http/httputil"
        "net/url"
        "strings"
        "sync/atomic"
        "time"

        "keystone-gateway/internal/config"

        "github.com/go-chi/chi/v5"
)

// GatewayBackend represents a proxied backend server with health status tracking.
type GatewayBackend struct {
        URL   *url.URL
        Alive atomic.Bool
}

// TenantRouter manages load balancing and backend selection for a specific tenant.
type TenantRouter struct {
        Name     string
        Backends []*GatewayBackend
        RRIndex  uint64
}

// Gateway is the main reverse proxy instance that handles routing,
// load balancing, and health checking for all configured tenants.
type Gateway struct {
        config        *config.Config
        pathRouters   map[string]*TenantRouter
        hostRouters   map[string]*TenantRouter
        hybridRouters map[string]map[string]*TenantRouter
        startTime     time.Time

        // New: Dynamic route registry for Lua-defined routes
        routeRegistry *LuaRouteRegistry
}

// NewGatewayWithRouter creates a Gateway with an existing Chi router for dynamic routing
func NewGatewayWithRouter(cfg *config.Config, router *chi.Mux) *Gateway <span class="cov8" title="1">{
        gw := &amp;Gateway{
                config:        cfg,
                pathRouters:   make(map[string]*TenantRouter),
                hostRouters:   make(map[string]*TenantRouter),
                hybridRouters: make(map[string]map[string]*TenantRouter),
                startTime:     time.Now(),
                routeRegistry: NewLuaRouteRegistry(router, nil),
        }

        gw.initializeRouters()
        return gw
}</span>

// initializeRouters sets up all tenant routers from the configuration.
func (gw *Gateway) initializeRouters() <span class="cov8" title="1">{
        for _, tenant := range gw.config.Tenants </span><span class="cov8" title="1">{
                tr := &amp;TenantRouter{
                        Name:     tenant.Name,
                        Backends: make([]*GatewayBackend, 0, len(tenant.Services)),
                }

                // Initialize backends
                for _, svc := range tenant.Services </span><span class="cov8" title="1">{
                        u, err := url.Parse(svc.URL)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: invalid URL for service %s: %v", svc.Name, err)
                                continue</span>
                        }

                        // Validate that the URL has the required components for a backend
                        <span class="cov8" title="1">if u.Scheme == "" || u.Host == "" </span><span class="cov8" title="1">{
                                log.Printf("Warning: invalid backend URL for service %s: missing scheme or host", svc.Name)
                                continue</span>
                        }

                        <span class="cov8" title="1">backend := &amp;GatewayBackend{URL: u}
                        backend.Alive.Store(false) // Start as unhealthy
                        tr.Backends = append(tr.Backends, backend)</span>
                }

                // Route based on configuration
                <span class="cov8" title="1">gw.registerTenantRoutes(tenant, tr)

                // TODO: Start health checks (will be moved to health package)

                log.Printf("Initialized tenant %s with %d backends", tenant.Name, len(tr.Backends))</span>
        }
}

// registerTenantRoutes registers tenant routes based on the configuration.
func (gw *Gateway) registerTenantRoutes(tenant config.Tenant, tr *TenantRouter) <span class="cov8" title="1">{
        if len(tenant.Domains) &gt; 0 &amp;&amp; tenant.PathPrefix != "" </span><span class="cov8" title="1">{
                // Hybrid routing
                for _, domain := range tenant.Domains </span><span class="cov8" title="1">{
                        if gw.hybridRouters[domain] == nil </span><span class="cov8" title="1">{
                                gw.hybridRouters[domain] = make(map[string]*TenantRouter)
                        }</span>
                        <span class="cov8" title="1">gw.hybridRouters[domain][tenant.PathPrefix] = tr</span>
                }
        } else<span class="cov8" title="1"> if len(tenant.Domains) &gt; 0 </span><span class="cov8" title="1">{
                // Host-only routing
                for _, domain := range tenant.Domains </span><span class="cov8" title="1">{
                        gw.hostRouters[domain] = tr
                }</span>
        } else<span class="cov8" title="1"> if tenant.PathPrefix != "" </span><span class="cov8" title="1">{
                // Path-only routing
                gw.pathRouters[tenant.PathPrefix] = tr
        }</span>
}

// MatchRoute finds the appropriate tenant router for a given host and path.
func (gw *Gateway) MatchRoute(host, path string) (*TenantRouter, string) <span class="cov8" title="1">{
        // Reject paths with null bytes
        for _, char := range path </span><span class="cov8" title="1">{
                if char == 0 </span><span class="cov8" title="1">{
                        return nil, ""
                }</span>
        }
        
        <span class="cov8" title="1">host = ExtractHost(host)

        // Priority 1: Hybrid routing (host + path)
        if hostMap, exists := gw.hybridRouters[host]; exists </span><span class="cov8" title="1">{
                if matched, prefix := gw.findBestPathMatch(path, hostMap); matched != nil </span><span class="cov8" title="1">{
                        return matched, prefix
                }</span>
        }

        // Priority 2: Host-only routing
        <span class="cov8" title="1">if router, exists := gw.hostRouters[host]; exists </span><span class="cov8" title="1">{
                return router, ""
        }</span>

        // Priority 3: Path-only routing
        <span class="cov8" title="1">return gw.findBestPathMatch(path, gw.pathRouters)</span>
}

// NextBackend returns the next healthy backend using round-robin algorithm.
func (tr *TenantRouter) NextBackend() *GatewayBackend <span class="cov8" title="1">{
        if len(tr.Backends) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Round-robin with health checks
        <span class="cov8" title="1">for i := 0; i &lt; len(tr.Backends); i++ </span><span class="cov8" title="1">{
                idx := int(atomic.AddUint64(&amp;tr.RRIndex, 1) % uint64(len(tr.Backends)))
                backend := tr.Backends[idx]

                if backend.Alive.Load() </span><span class="cov8" title="1">{
                        return backend
                }</span>
        }

        // Fallback to first backend even if unhealthy
        <span class="cov8" title="1">return tr.Backends[0]</span>
}

// GetTenantRouter finds a tenant router by name.
func (gw *Gateway) GetTenantRouter(name string) *TenantRouter <span class="cov8" title="1">{
        for _, tr := range gw.pathRouters </span><span class="cov8" title="1">{
                if tr.Name == name </span><span class="cov8" title="1">{
                        return tr
                }</span>
        }
        <span class="cov8" title="1">for _, tr := range gw.hostRouters </span><span class="cov8" title="1">{
                if tr.Name == name </span><span class="cov8" title="1">{
                        return tr
                }</span>
        }
        <span class="cov8" title="1">for _, hostMap := range gw.hybridRouters </span><span class="cov8" title="1">{
                for _, tr := range hostMap </span><span class="cov8" title="1">{
                        if tr.Name == name </span><span class="cov8" title="1">{
                                return tr
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// GetConfig returns the gateway configuration.
func (gw *Gateway) GetConfig() *config.Config <span class="cov0" title="0">{
        return gw.config
}</span>

// GetStartTime returns when the gateway was started.
func (gw *Gateway) GetStartTime() time.Time <span class="cov0" title="0">{
        return gw.startTime
}</span>

// GetRouteRegistry returns the dynamic route registry
func (gw *Gateway) GetRouteRegistry() *LuaRouteRegistry <span class="cov8" title="1">{
        return gw.routeRegistry
}</span>

// extractHost extracts the hostname from a host header (removing port if present).
func ExtractHost(hostHeader string) string <span class="cov8" title="1">{
        // Handle IPv6 addresses wrapped in brackets: [::1]:8080 -&gt; [::1]
        if strings.HasPrefix(hostHeader, "[") </span><span class="cov8" title="1">{
                if closeBracket := strings.Index(hostHeader, "]"); closeBracket != -1 </span><span class="cov8" title="1">{
                        return hostHeader[:closeBracket+1]
                }</span>
        }
        
        // Handle IPv4 addresses or hostnames: example.com:8080 -&gt; example.com  
        <span class="cov8" title="1">if colonIndex := strings.Index(hostHeader, ":"); colonIndex != -1 </span><span class="cov8" title="1">{
                return hostHeader[:colonIndex]
        }</span>
        <span class="cov8" title="1">return hostHeader</span>
}

// findBestPathMatch finds the best matching path prefix from a router map
func (gw *Gateway) findBestPathMatch(path string, routers map[string]*TenantRouter) (*TenantRouter, string) <span class="cov8" title="1">{
        var matched *TenantRouter
        var matchedPrefix string

        for prefix, router := range routers </span><span class="cov8" title="1">{
                if strings.HasPrefix(path, prefix) &amp;&amp; len(prefix) &gt; len(matchedPrefix) </span><span class="cov8" title="1">{
                        matched = router
                        matchedPrefix = prefix
                }</span>
        }

        <span class="cov8" title="1">return matched, matchedPrefix</span>
}

// CreateProxy creates a reverse proxy for the given backend
func (gw *Gateway) CreateProxy(backend *GatewayBackend, stripPrefix string) *httputil.ReverseProxy <span class="cov8" title="1">{
        proxy := httputil.NewSingleHostReverseProxy(backend.URL)

        proxy.Director = func(req *http.Request) </span><span class="cov8" title="1">{
                req.URL.Scheme = backend.URL.Scheme
                req.URL.Host = backend.URL.Host

                // Handle path stripping and backend path prepending
                if stripPrefix != "" </span><span class="cov8" title="1">{
                        newPath := strings.TrimPrefix(req.URL.Path, stripPrefix)
                        if newPath == "" </span><span class="cov8" title="1">{
                                newPath = "/"
                        }</span> else<span class="cov8" title="1"> if !strings.HasPrefix(newPath, "/") </span><span class="cov8" title="1">{
                                newPath = "/" + newPath
                        }</span>
                        <span class="cov8" title="1">req.URL.Path = newPath</span>
                }

                // Prepend backend URL path if it exists
                <span class="cov8" title="1">if backend.URL.Path != "" &amp;&amp; backend.URL.Path != "/" </span><span class="cov0" title="0">{
                        backendPath := strings.TrimSuffix(backend.URL.Path, "/")
                        if req.URL.Path == "/" </span><span class="cov0" title="0">{
                                req.URL.Path = backendPath + "/"
                        }</span> else<span class="cov0" title="0"> {
                                req.URL.Path = backendPath + req.URL.Path
                        }</span>
                }

                // Merge query parameters
                <span class="cov8" title="1">if backend.URL.RawQuery == "" || req.URL.RawQuery == "" </span><span class="cov8" title="1">{
                        req.URL.RawQuery = backend.URL.RawQuery + req.URL.RawQuery
                }</span> else<span class="cov0" title="0"> {
                        req.URL.RawQuery = backend.URL.RawQuery + "&amp;" + req.URL.RawQuery
                }</span>
        }

        <span class="cov8" title="1">return proxy</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package routing provides dynamic route registration capabilities for Lua scripts.
// This file defines the API that allows Lua scripts to register routes, middleware,
// and route groups directly with the Chi router at runtime.
package routing

import (
        "fmt"
        "net/http"
        "strings"
        "sync"

        "github.com/go-chi/chi/v5"
        lua "github.com/yuin/gopher-lua"
)

// LuaRouteRegistry manages dynamic route registration from Lua scripts with thread safety
type LuaRouteRegistry struct {
        router           *chi.Mux
        routeGroups      map[string]*chi.Mux // tenant -&gt; submux for tenant routes
        registeredRoutes map[string]bool     // track registered routes to prevent duplicates
        middleware       map[string][]MiddlewareDefinition // tenant -&gt; middleware definitions
        mu               sync.RWMutex        // protects routeGroups and registeredRoutes maps
        Engine           interface {
                GetScript(string) (string, bool)
                SetupChiBindings(*lua.LState, string, string)
        }
}

// RouteDefinition represents a route registered by Lua
type RouteDefinition struct {
        TenantName   string
        Method       string
        Pattern      string
        GroupPattern string // Group context (empty if global, "/api/v1" if in group)
        Handler      http.HandlerFunc
}

// MiddlewareDefinition represents middleware registered by Lua
type MiddlewareDefinition struct {
        TenantName   string
        Pattern      string // Pattern to match for middleware (e.g., "/api/*")
        GroupPattern string // Group context (empty if global, "/api/v1" if in group)
        Middleware   func(http.Handler) http.Handler
}

// RouteGroupDefinition represents a route group registered by Lua
type RouteGroupDefinition struct {
        TenantName string
        Pattern    string
        Middleware []func(http.Handler) http.Handler
        Routes     []RouteDefinition
        Subgroups  []RouteGroupDefinition
}

// NewLuaRouteRegistry creates a new registry for Lua-defined routes
func NewLuaRouteRegistry(router *chi.Mux, engine interface {
        GetScript(string) (string, bool)
        SetupChiBindings(*lua.LState, string, string)
}) *LuaRouteRegistry <span class="cov8" title="1">{
        return &amp;LuaRouteRegistry{
                router:           router,
                routeGroups:      make(map[string]*chi.Mux),
                registeredRoutes: make(map[string]bool),
                middleware:       make(map[string][]MiddlewareDefinition),
                Engine:           engine,
        }
}</span>

// RegisterRoute registers a single route from a Lua script with duplicate prevention
func (r *LuaRouteRegistry) RegisterRoute(def RouteDefinition) error <span class="cov8" title="1">{
        // Create unique route key
        routeKey := fmt.Sprintf("%s:%s:%s", def.TenantName, def.Method, def.Pattern)

        // Check if route already exists
        r.mu.Lock()
        if r.registeredRoutes[routeKey] </span><span class="cov8" title="1">{
                r.mu.Unlock()
                // Route already exists, skip registration
                return nil
        }</span>
        <span class="cov8" title="1">r.registeredRoutes[routeKey] = true
        r.mu.Unlock()

        // Validate route pattern before registration
        if err := validateRoutePattern(def.Pattern); err != nil </span><span class="cov8" title="1">{
                // Remove from registered routes since validation failed
                r.mu.Lock()
                delete(r.registeredRoutes, routeKey)
                r.mu.Unlock()
                return fmt.Errorf("invalid route pattern '%s': %w", def.Pattern, err)
        }</span>

        // Get or create tenant submux
        <span class="cov8" title="1">submux := r.getTenantSubmux(def.TenantName)

        // Register the route with the appropriate method
        // Note: middleware application is handled inside registerRouteByMethod via applyMiddleware
        r.registerRouteByMethod(submux, RouteDefinition{
                TenantName:   def.TenantName,
                Method:       def.Method,
                Pattern:      def.Pattern,
                GroupPattern: def.GroupPattern,
                Handler:      def.Handler,
        })

        return nil</span>
}

// RegisterMiddleware registers middleware for a pattern from a Lua script
func (r *LuaRouteRegistry) RegisterMiddleware(def MiddlewareDefinition) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        
        // Store the middleware definition for later application
        r.middleware[def.TenantName] = append(r.middleware[def.TenantName], def)
        
        return nil
}</span>

// RegisterRouteGroup registers a group of routes with shared middleware with duplicate prevention
func (r *LuaRouteRegistry) RegisterRouteGroup(def RouteGroupDefinition) error <span class="cov8" title="1">{
        // Create unique group key
        groupKey := fmt.Sprintf("%s:group:%s", def.TenantName, def.Pattern)

        // Check if group already exists
        r.mu.Lock()
        if r.registeredRoutes[groupKey] </span><span class="cov0" title="0">{
                r.mu.Unlock()
                // Group already exists, skip registration
                return nil
        }</span>
        <span class="cov8" title="1">r.registeredRoutes[groupKey] = true
        r.mu.Unlock()

        submux := r.getTenantSubmux(def.TenantName)

        // Create route group with pattern and middleware
        submux.Route(def.Pattern, func(gr chi.Router) </span><span class="cov8" title="1">{
                // Apply group middleware
                for _, mw := range def.Middleware </span><span class="cov8" title="1">{
                        gr.Use(mw)
                }</span>

                // Register routes in the group
                <span class="cov8" title="1">for _, route := range def.Routes </span><span class="cov8" title="1">{
                        r.registerRouteByMethod(gr, route)
                }</span>

                // Register subgroups recursively
                <span class="cov8" title="1">for _, subgroup := range def.Subgroups </span><span class="cov0" title="0">{
                        r.registerSubgroup(gr, subgroup)
                }</span>
        })

        <span class="cov8" title="1">return nil</span>
}

// MountTenantRoutes mounts all routes for a tenant under a specific path
func (r *LuaRouteRegistry) MountTenantRoutes(tenantName, mountPath string) error <span class="cov8" title="1">{
        r.mu.RLock()
        submux, exists := r.routeGroups[tenantName]
        r.mu.RUnlock()

        if exists </span><span class="cov8" title="1">{
                r.router.Mount(mountPath, submux)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ClearTenantRoutes removes all routes for a specific tenant
func (r *LuaRouteRegistry) ClearTenantRoutes(tenantName string) <span class="cov8" title="1">{
        delete(r.routeGroups, tenantName)
}</span>

// GetTenantRoutes returns the submux for a tenant (for inspection/debugging)
func (r *LuaRouteRegistry) GetTenantRoutes(tenantName string) *chi.Mux <span class="cov8" title="1">{
        return r.routeGroups[tenantName]
}</span>

// ListTenants returns all tenants that have registered routes
func (r *LuaRouteRegistry) ListTenants() []string <span class="cov8" title="1">{
        tenants := make([]string, 0, len(r.routeGroups))
        for tenant := range r.routeGroups </span><span class="cov8" title="1">{
                tenants = append(tenants, tenant)
        }</span>
        <span class="cov8" title="1">return tenants</span>
}

// getTenantSubmux gets or creates a submux for a tenant
func (r *LuaRouteRegistry) getTenantSubmux(tenantName string) *chi.Mux <span class="cov8" title="1">{
        // Check if submux exists (read lock)
        r.mu.RLock()
        if submux, exists := r.routeGroups[tenantName]; exists </span><span class="cov8" title="1">{
                r.mu.RUnlock()
                return submux
        }</span>
        <span class="cov8" title="1">r.mu.RUnlock()

        // Create new submux for tenant (write lock)
        r.mu.Lock()
        defer r.mu.Unlock()

        // Double-check pattern - another goroutine might have created it
        if submux, exists := r.routeGroups[tenantName]; exists </span><span class="cov0" title="0">{
                return submux
        }</span>

        <span class="cov8" title="1">submux := chi.NewMux()
        r.routeGroups[tenantName] = submux
        return submux</span>
}

// getMatchingMiddleware returns all middleware that matches the given route pattern
func (r *LuaRouteRegistry) getMatchingMiddleware(tenantName, routePattern string) []func(http.Handler) http.Handler <span class="cov0" title="0">{
        r.mu.RLock()
        middlewares := r.middleware[tenantName]
        r.mu.RUnlock()

        var matching []func(http.Handler) http.Handler
        for _, mw := range middlewares </span><span class="cov0" title="0">{
                // Check if the route pattern matches the middleware pattern
                if r.patternMatches(routePattern, mw.Pattern) </span><span class="cov0" title="0">{
                        matching = append(matching, mw.Middleware)
                }</span>
        }
        <span class="cov0" title="0">return matching</span>
}

// wrapHandlerWithMiddleware wraps a handler with a chain of middleware
func (r *LuaRouteRegistry) wrapHandlerWithMiddleware(handler http.HandlerFunc, middleware []func(http.Handler) http.Handler) http.HandlerFunc <span class="cov0" title="0">{
        // Apply middleware in reverse order (last middleware wraps first)
        wrapped := http.Handler(handler)
        for i := len(middleware) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                wrapped = middleware[i](wrapped)
        }</span>
        <span class="cov0" title="0">return wrapped.ServeHTTP</span>
}

// patternMatches checks if a route pattern matches a middleware pattern
// For simplicity, we use basic pattern matching with wildcards
func (r *LuaRouteRegistry) patternMatches(routePattern, middlewarePattern string) bool <span class="cov0" title="0">{
        // Handle exact matches
        if routePattern == middlewarePattern </span><span class="cov0" title="0">{
                return true
        }</span>
        
        // Handle wildcard patterns (e.g., "/protected/*" matches "/protected/data")
        <span class="cov0" title="0">if strings.HasSuffix(middlewarePattern, "/*") </span><span class="cov0" title="0">{
                prefix := strings.TrimSuffix(middlewarePattern, "/*")
                return strings.HasPrefix(routePattern, prefix)
        }</span>
        
        <span class="cov0" title="0">return false</span>
}

// applyMatchingMiddleware wraps a handler with all matching middleware for the route
func (r *LuaRouteRegistry) applyMatchingMiddleware(handler http.HandlerFunc, tenantName, routePattern string) http.HandlerFunc <span class="cov0" title="0">{
        r.mu.RLock()
        middlewares := r.middleware[tenantName]
        r.mu.RUnlock()
        
        // Find matching middleware
        var matchingMiddleware []func(http.Handler) http.Handler
        for _, mw := range middlewares </span><span class="cov0" title="0">{
                if r.patternMatches(routePattern, mw.Pattern) </span><span class="cov0" title="0">{
                        matchingMiddleware = append(matchingMiddleware, mw.Middleware)
                }</span>
        }
        
        // If no middleware matches, return original handler
        <span class="cov0" title="0">if len(matchingMiddleware) == 0 </span><span class="cov0" title="0">{
                return handler
        }</span>
        
        // Apply middleware chain
        <span class="cov0" title="0">wrapped := http.Handler(handler)
        for i := len(matchingMiddleware) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                wrapped = matchingMiddleware[i](wrapped)
        }</span>
        
        <span class="cov0" title="0">return wrapped.ServeHTTP</span>
}

// registerSubgroup recursively registers subgroups
func (r *LuaRouteRegistry) registerSubgroup(parent chi.Router, def RouteGroupDefinition) <span class="cov0" title="0">{
        parent.Route(def.Pattern, func(gr chi.Router) </span><span class="cov0" title="0">{
                // Apply group middleware
                for _, mw := range def.Middleware </span><span class="cov0" title="0">{
                        gr.Use(mw)
                }</span>

                // Register routes in the subgroup
                <span class="cov0" title="0">for _, route := range def.Routes </span><span class="cov0" title="0">{
                        r.registerRouteByMethod(gr, route)
                }</span>
                // Register nested subgroups
                <span class="cov0" title="0">for _, subgroup := range def.Subgroups </span><span class="cov0" title="0">{
                        r.registerSubgroup(gr, subgroup)
                }</span>
        })
}

// RouteRegistryAPI provides the high-level API for Lua script integration
type RouteRegistryAPI struct {
        registry *LuaRouteRegistry
}

// NewRouteRegistryAPI creates a new API wrapper
func NewRouteRegistryAPI(router *chi.Mux) *RouteRegistryAPI <span class="cov0" title="0">{
        return &amp;RouteRegistryAPI{
                registry: NewLuaRouteRegistry(router, nil),
        }
}</span>

// Route registers a simple route (called from Lua via chi_route function)
func (api *RouteRegistryAPI) Route(tenantName, method, pattern string, handler http.HandlerFunc) error <span class="cov0" title="0">{
        return api.registry.RegisterRoute(RouteDefinition{
                TenantName: tenantName,
                Method:     method,
                Pattern:    pattern,
                Handler:    handler,
        })
}</span>

// Middleware registers middleware for a pattern (called from Lua via chi_middleware function)
func (api *RouteRegistryAPI) Middleware(tenantName, pattern string, middleware func(http.Handler) http.Handler) error <span class="cov0" title="0">{
        return api.registry.RegisterMiddleware(MiddlewareDefinition{
                TenantName: tenantName,
                Pattern:    pattern,
                Middleware: middleware,
        })
}</span>

// Group registers a route group (called from Lua via chi_group function)
func (api *RouteRegistryAPI) Group(tenantName, pattern string, middleware []func(http.Handler) http.Handler, setupFunc func(*RouteRegistryAPI)) error <span class="cov0" title="0">{
        // This will be used by the Lua bindings to set up groups
        // The setupFunc will be called with the API to register routes within the group
        def := RouteGroupDefinition{
                TenantName: tenantName,
                Pattern:    pattern,
                Middleware: middleware,
                Routes:     []RouteDefinition{},
                Subgroups:  []RouteGroupDefinition{},
        }

        return api.registry.RegisterRouteGroup(def)
}</span>

// Mount mounts tenant routes under a path (called from Lua via chi_mount function)
func (api *RouteRegistryAPI) Mount(tenantName, mountPath string) error <span class="cov0" title="0">{
        return api.registry.MountTenantRoutes(tenantName, mountPath)
}</span>

// Clear removes all routes for a tenant
func (api *RouteRegistryAPI) Clear(tenantName string) <span class="cov0" title="0">{
        api.registry.ClearTenantRoutes(tenantName)
}</span>

// registerRouteByMethod consolidates the duplicate route registration logic
func (r *LuaRouteRegistry) registerRouteByMethod(router chi.Router, route RouteDefinition) <span class="cov8" title="1">{
        // Apply middleware that matches this route pattern
        handler := r.applyMiddleware(route)
        
        switch route.Method </span>{
        case "GET":<span class="cov8" title="1">
                router.Get(route.Pattern, handler)</span>
        case "POST":<span class="cov8" title="1">
                router.Post(route.Pattern, handler)</span>
        case "PUT":<span class="cov8" title="1">
                router.Put(route.Pattern, handler)</span>
        case "DELETE":<span class="cov8" title="1">
                router.Delete(route.Pattern, handler)</span>
        case "PATCH":<span class="cov8" title="1">
                router.Patch(route.Pattern, handler)</span>
        case "OPTIONS":<span class="cov0" title="0">
                router.Options(route.Pattern, handler)</span>
        case "HEAD":<span class="cov0" title="0">
                router.Head(route.Pattern, handler)</span>
        default:<span class="cov8" title="1">
                // Handle custom methods that Chi might not support
                func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if r := recover(); r != nil </span><span class="cov8" title="1">{
                                        // Chi doesn't support this HTTP method, silently skip
                                        fmt.Printf("Warning: HTTP method '%s' is not supported by Chi router\n", route.Method)
                                }</span>
                        }()
                        <span class="cov8" title="1">router.Method(route.Method, route.Pattern, handler)</span>
                }()
        }
}

// applyMiddleware applies middleware that matches the route pattern
func (r *LuaRouteRegistry) applyMiddleware(route RouteDefinition) http.HandlerFunc <span class="cov8" title="1">{
        r.mu.RLock()
        middlewares := r.middleware[route.TenantName]
        r.mu.RUnlock()
        
        var handler http.Handler = route.Handler
        
        // Apply middleware in reverse order (last registered middleware wraps first)
        for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                mw := middlewares[i]
                if r.routeMatchesPattern(route, mw) </span><span class="cov8" title="1">{
                        handler = mw.Middleware(handler)
                }</span>
        }
        
        <span class="cov8" title="1">return handler.ServeHTTP</span>
}

// routeMatchesPattern checks if a route pattern matches a middleware pattern
// considering group context for proper scoping
func (r *LuaRouteRegistry) routeMatchesPattern(route RouteDefinition, middleware MiddlewareDefinition) bool <span class="cov8" title="1">{
        // Get the effective patterns to compare
        middlewarePattern := middleware.Pattern
        routePattern := route.Pattern
        
        // Handle group-scoped middleware
        if middleware.GroupPattern != "" </span><span class="cov8" title="1">{
                // Group middleware: only applies to routes in the same group
                if middleware.GroupPattern != route.GroupPattern </span><span class="cov8" title="1">{
                        return false
                }</span>
                // For group middleware, resolve the pattern relative to the group
                // e.g., group="/api/v1", middleware pattern="/*" should match "/api/v1/users"
                <span class="cov8" title="1">middlewarePattern = middleware.GroupPattern + middleware.Pattern</span>
        }
        // Global middleware (empty GroupPattern): applies to all routes regardless of group
        
        // Handle wildcard patterns like "/protected/*" or "/api/v1/*"
        <span class="cov8" title="1">if strings.HasSuffix(middlewarePattern, "/*") </span><span class="cov8" title="1">{
                prefix := strings.TrimSuffix(middlewarePattern, "/*")
                return strings.HasPrefix(routePattern, prefix)
        }</span>
        
        // Exact match
        <span class="cov8" title="1">return routePattern == middlewarePattern</span>
}

// validateRoutePattern validates Chi router pattern format
func validateRoutePattern(pattern string) error <span class="cov8" title="1">{
        if pattern == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("route pattern cannot be empty")
        }</span>
        
        <span class="cov8" title="1">if !strings.HasPrefix(pattern, "/") </span><span class="cov8" title="1">{
                return fmt.Errorf("route pattern must begin with '/'")
        }</span>
        
        // Check for unmatched parameter braces
        <span class="cov8" title="1">braceCount := 0
        for i, char := range pattern </span><span class="cov8" title="1">{
                if char == '{' </span><span class="cov8" title="1">{
                        braceCount++
                }</span> else<span class="cov8" title="1"> if char == '}' </span><span class="cov8" title="1">{
                        braceCount--
                        if braceCount &lt; 0 </span><span class="cov8" title="1">{
                                return fmt.Errorf("unmatched closing brace '}' at position %d", i)
                        }</span>
                }
        }
        
        <span class="cov8" title="1">if braceCount &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("route param closing delimiter '}' is missing")
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
