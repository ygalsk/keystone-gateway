
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">keystone-gateway/internal/config/config.go (95.0%)</option>
				
				<option value="file1">keystone-gateway/internal/lua/chi_bindings.go (25.8%)</option>
				
				<option value="file2">keystone-gateway/internal/lua/engine.go (84.9%)</option>
				
				<option value="file3">keystone-gateway/internal/lua/state_pool.go (68.9%)</option>
				
				<option value="file4">keystone-gateway/internal/routing/gateway.go (28.6%)</option>
				
				<option value="file5">keystone-gateway/internal/routing/lua_routes.go (37.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package config provides configuration management for Keystone Gateway.
// It handles loading, parsing, and validating YAML configuration files.
package config

import (
        "fmt"
        "os"
        "strings"

        "gopkg.in/yaml.v3"
)

// LuaRoutingConfig represents embedded Lua routing configuration
type LuaRoutingConfig struct {
        Enabled       bool     `yaml:"enabled"`
        ScriptsDir    string   `yaml:"scripts_dir,omitempty"`
        GlobalScripts []string `yaml:"global_scripts,omitempty"`
}

// TLSConfig represents TLS configuration for the gateway
type TLSConfig struct {
        Enabled  bool   `yaml:"enabled"`
        CertFile string `yaml:"cert_file"`
        KeyFile  string `yaml:"key_file"`
}

// Config represents the main configuration structure for the gateway,
// containing tenant definitions and admin settings.
type Config struct {
        Tenants       []Tenant          `yaml:"tenants"`
        AdminBasePath string            `yaml:"admin_base_path,omitempty"`
        LuaRouting    *LuaRoutingConfig `yaml:"lua_routing,omitempty"` // Embedded Lua routing only
        TLS           *TLSConfig        `yaml:"tls,omitempty"`
}

// Tenant represents a routing configuration for a specific application or service,
// supporting host-based, path-based, or hybrid routing strategies.
type Tenant struct {
        Name       string    `yaml:"name"`
        PathPrefix string    `yaml:"path_prefix,omitempty"`
        Domains    []string  `yaml:"domains,omitempty"`
        Interval   int       `yaml:"health_interval"`
        LuaRoutes  string    `yaml:"lua_routes,omitempty"` // Script for route definition
        Services   []Service `yaml:"services"`
}

// Service represents a backend service endpoint with health check configuration.
type Service struct {
        Name   string `yaml:"name"`
        URL    string `yaml:"url"`
        Health string `yaml:"health"`
}

// LoadConfig reads and parses a YAML configuration file, returning a validated Config instance.
// Returns an error if the file cannot be read, parsed, or contains invalid tenant configurations.
func LoadConfig(path string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config: %w", err)
        }</span>

        <span class="cov8" title="1">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov8" title="1">for _, tenant := range cfg.Tenants </span><span class="cov8" title="1">{
                if err := ValidateTenant(tenant); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid tenant %s: %w", tenant.Name, err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// ValidateTenant validates a tenant configuration for correctness.
func ValidateTenant(t Tenant) error <span class="cov8" title="1">{
        if len(t.Domains) == 0 &amp;&amp; t.PathPrefix == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("must specify either domains or path_prefix")
        }</span>

        <span class="cov8" title="1">for _, domain := range t.Domains </span><span class="cov8" title="1">{
                if !isValidDomain(domain) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid domain: %s", domain)
                }</span>
        }

        <span class="cov8" title="1">if t.PathPrefix != "" </span><span class="cov8" title="1">{
                if !strings.HasPrefix(t.PathPrefix, "/") || !strings.HasSuffix(t.PathPrefix, "/") </span><span class="cov8" title="1">{
                        return fmt.Errorf("path_prefix must start and end with '/'")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isValidDomain performs basic domain name validation.
func isValidDomain(domain string) bool <span class="cov8" title="1">{
        return domain != "" &amp;&amp; !strings.Contains(domain, " ") &amp;&amp; strings.Contains(domain, ".")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package lua provides Lua-to-Chi bridge functions that allow Lua scripts
// to register routes, middleware, and route groups directly with the Chi router.
package lua

import (
        "fmt"
        "net/http"

        lua "github.com/yuin/gopher-lua"

        "keystone-gateway/internal/routing"
)

// setupChiBindings sets up Lua bindings for Chi router functions
func (e *Engine) SetupChiBindings(L *lua.LState, scriptTag, tenantName string) <span class="cov8" title="1">{
        // Register Lua functions that can be called from scripts
        L.SetGlobal("chi_route", L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                return e.luaChiRoute(L, scriptTag, tenantName)
        }</span>))
        <span class="cov8" title="1">L.SetGlobal("chi_middleware", L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                return e.luaChiMiddleware(L, tenantName)
        }</span>))
        <span class="cov8" title="1">L.SetGlobal("chi_group", L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                return e.luaChiGroup(L, tenantName)
        }</span>))
        <span class="cov8" title="1">L.SetGlobal("chi_param", L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                // This will be overridden in the actual handler context with real parameter values
                requestTable := L.ToTable(1)
                paramName := L.ToString(2)

                if requestTable != nil </span><span class="cov0" title="0">{
                        if paramsTable := requestTable.RawGetString("params"); paramsTable != lua.LNil </span><span class="cov0" title="0">{
                                if paramTable, ok := paramsTable.(*lua.LTable); ok </span><span class="cov0" title="0">{
                                        if param := paramTable.RawGetString(paramName); param != lua.LNil </span><span class="cov0" title="0">{
                                                L.Push(param)
                                                return 1
                                        }</span>
                                }
                        }
                }

                // Default fallback
                <span class="cov0" title="0">L.Push(lua.LString(""))
                return 1</span>
        }))
}

// luaChiRoute handles route registration from Lua: chi_route(method, pattern, handler)
func (e *Engine) luaChiRoute(L *lua.LState, scriptTag, tenantName string) int <span class="cov8" title="1">{
        method := L.ToString(1)
        pattern := L.ToString(2)
        handlerFunc := L.ToFunction(3)

        if method == "" || pattern == "" || handlerFunc == nil </span><span class="cov0" title="0">{
                L.ArgError(1, "chi_route requires method, pattern, and handler function")
                return 0
        }</span>

        // Extract the Lua function source code for later execution
        <span class="cov8" title="1">functionName := fmt.Sprintf("handler_%s_%s_%d", method, pattern, L.GetTop())
        L.SetGlobal(functionName, handlerFunc)

        // Get the script content for this handler
        scriptContent, exists := e.GetScript(scriptTag)
        if !exists </span><span class="cov0" title="0">{
                L.RaiseError("Script not found: %s", scriptTag)
                return 0
        }</span>

        // Create a thread-safe handler using the state pool
        <span class="cov8" title="1">luaHandler := NewLuaHandler(scriptContent, functionName, tenantName, scriptTag, e.statePool, e)

        // Register the route with the simplified registry
        err := e.routeRegistry.RegisterRoute(routing.RouteDefinition{
                TenantName: tenantName,
                Method:     method,
                Pattern:    pattern,
                Handler:    luaHandler.ServeHTTP,
        })
        if err != nil </span><span class="cov0" title="0">{
                L.RaiseError("Failed to register route: %v", err)
        }</span>

        <span class="cov8" title="1">return 0</span>
}

// luaChiMiddleware handles middleware registration: chi_middleware(pattern, middleware_func)
func (e *Engine) luaChiMiddleware(L *lua.LState, tenantName string) int <span class="cov0" title="0">{
        pattern := L.ToString(1)
        middlewareFunc := L.ToFunction(2)

        if pattern == "" || middlewareFunc == nil </span><span class="cov0" title="0">{
                L.ArgError(1, "chi_middleware requires pattern and middleware function")
                return 0
        }</span>

        // Create Go middleware that calls the Lua function using state pool for safety
        <span class="cov0" title="0">middleware := func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Use state pool for thread-safe middleware execution
                        L := e.statePool.Get()
                        defer e.statePool.Put(L)

                        // Execute middleware function with proper context
                        respWriter := &amp;luaResponseWriter{w: w}
                        respTable := createLuaResponse(L, respWriter)
                        reqTable := createLuaRequest(L, r)

                        // Create next function wrapper
                        nextFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return 0
                        }</span>)

                        // Call middleware function
                        <span class="cov0" title="0">err := L.CallByParam(lua.P{
                                Fn:      middlewareFunc,
                                NRet:    0,
                                Protect: true,
                        }, nextFunc, respTable, reqTable)

                        if err != nil </span><span class="cov0" title="0">{
                                // On error, continue to next handler
                                next.ServeHTTP(w, r)
                        }</span>
                })
        }

        // Register with the route registry
        <span class="cov0" title="0">err := e.routeRegistry.RegisterMiddleware(routing.MiddlewareDefinition{
                TenantName: tenantName,
                Pattern:    pattern,
                Middleware: middleware,
        })
        if err != nil </span><span class="cov0" title="0">{
                L.RaiseError("Failed to register middleware: %v", err)
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// luaChiGroup handles route group registration: chi_group(pattern, setup_func)
func (e *Engine) luaChiGroup(L *lua.LState, tenantName string) int <span class="cov0" title="0">{
        pattern := L.ToString(1)
        setupFunc := L.ToFunction(2)

        if pattern == "" || setupFunc == nil </span><span class="cov0" title="0">{
                L.ArgError(1, "chi_group requires pattern and setup function")
                return 0
        }</span>

        // Simplified group implementation
        <span class="cov0" title="0">groupDef := routing.RouteGroupDefinition{
                TenantName: tenantName,
                Pattern:    pattern,
                Middleware: []func(http.Handler) http.Handler{},
                Routes:     []routing.RouteDefinition{},
                Subgroups:  []routing.RouteGroupDefinition{},
        }

        err := e.routeRegistry.RegisterRouteGroup(groupDef)
        if err != nil </span><span class="cov0" title="0">{
                L.RaiseError("Failed to register route group: %v", err)
        }</span>

        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package lua provides an embedded Lua scripting engine for dynamic route registration.
// This replaces the external lua-stone service with an embedded gopher-lua engine
// that can register routes directly with the Chi router.
package lua

import (
        "context"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/go-chi/chi/v5"
        lua "github.com/yuin/gopher-lua"

        "keystone-gateway/internal/routing"
)

const (
        // MaxScriptExecutionTime limits how long a lua script can run
        MaxScriptExecutionTime = 5 * time.Second
        // MaxMemoryMB limits lua script memory usage (disabled for performance)
        MaxMemoryMB = 10
        // DefaultStatePoolSize is the default number of Lua states in the pool
        DefaultStatePoolSize = 10
        // LuaCallStackSize sets the call stack size for Lua states
        LuaCallStackSize = 120
        // LuaRegistrySize sets the registry size for Lua states
        LuaRegistrySize = 120 * 20
        // DefaultDirMode is the default permission for created directories
        DefaultDirMode = 0755
        // DefaultFileMode is the default permission for created files
        DefaultFileMode = 0644
)

// Engine manages embedded Lua script execution and route registration
type Engine struct {
        scriptsDir    string
        scriptPaths   map[string]string         // script_tag -&gt; file_path
        globalPaths   map[string]string         // global_script_tag -&gt; file_path
        scriptCache   map[string]string         // script_tag -&gt; cached_content
        globalCache   map[string]string         // global_script_tag -&gt; cached_content
        cacheMutex    sync.RWMutex              // Protects cache access
        router        *chi.Mux                  // Chi router for dynamic route registration
        routeRegistry *routing.LuaRouteRegistry // Route registry for Lua integration
        statePool     *LuaStatePool             // Pool of Lua states for thread safety
}

// GetScript returns the script content for a given scriptTag, loading it if necessary
func (e *Engine) GetScript(scriptTag string) (string, bool) <span class="cov8" title="1">{
        e.cacheMutex.RLock()
        if script, cached := e.scriptCache[scriptTag]; cached </span><span class="cov8" title="1">{
                e.cacheMutex.RUnlock()
                return script, true
        }</span>
        <span class="cov8" title="1">e.cacheMutex.RUnlock()

        // Check if we have the path for this script
        path, exists := e.scriptPaths[scriptTag]
        if !exists </span><span class="cov8" title="1">{
                return "", false
        }</span>

        // Load the script content
        <span class="cov8" title="1">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to load script %s: %v", scriptTag, err)
                return "", false
        }</span>

        // Cache the loaded content
        <span class="cov8" title="1">e.cacheMutex.Lock()
        e.scriptCache[scriptTag] = string(content)
        e.cacheMutex.Unlock()

        return string(content), true</span>
}

// RouteRegistry returns the route registry for mounting tenant routes
func (e *Engine) RouteRegistry() *routing.LuaRouteRegistry <span class="cov8" title="1">{
        return e.routeRegistry
}</span>

// NewEngine creates a new embedded Lua engine
func NewEngine(scriptsDir string, router *chi.Mux) *Engine <span class="cov8" title="1">{
        engine := &amp;Engine{
                scriptsDir:  scriptsDir,
                scriptPaths: make(map[string]string),
                globalPaths: make(map[string]string),
                scriptCache: make(map[string]string),
                globalCache: make(map[string]string),
                router:      router,
        }
        engine.routeRegistry = routing.NewLuaRouteRegistry(router, engine)

        // Create Lua state pool for thread-safe request handling - prevents segfaults
        engine.statePool = NewLuaStatePool(DefaultStatePoolSize, func() *lua.LState </span><span class="cov8" title="1">{
                L := lua.NewState(lua.Options{
                        CallStackSize: LuaCallStackSize,
                        RegistrySize:  LuaRegistrySize,
                })
                // Setup basic Lua bindings for each state
                engine.setupBasicBindings(L)
                return L
        }</span>)

        <span class="cov8" title="1">engine.loadScriptPaths()
        return engine</span>
}

// setupBasicBindings sets up basic Lua functions that all states need
func (e *Engine) setupBasicBindings(L *lua.LState) <span class="cov8" title="1">{
        // Add basic logging function
        L.SetGlobal("log", L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                message := L.ToString(1)
                log.Printf("[Lua] %s", message)
                return 0
        }</span>))
}

// loadScriptPaths discovers and maps script files without loading content
func (e *Engine) loadScriptPaths() <span class="cov8" title="1">{
        if _, err := os.Stat(e.scriptsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                log.Printf("Scripts directory %s does not exist, creating...", e.scriptsDir)
                os.MkdirAll(e.scriptsDir, DefaultDirMode)
                return
        }</span>

        <span class="cov8" title="1">err := filepath.Walk(e.scriptsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil || !strings.HasSuffix(path, ".lua") </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">scriptName := strings.TrimSuffix(filepath.Base(path), ".lua")
                
                // Check if this is a global script (global-*.lua)
                if strings.HasPrefix(scriptName, "global-") </span><span class="cov8" title="1">{
                        globalScriptName := strings.TrimPrefix(scriptName, "global-")
                        e.globalPaths[globalScriptName] = path
                        log.Printf("Discovered global script: %s at %s", globalScriptName, path)
                }</span> else<span class="cov8" title="1"> {
                        e.scriptPaths[scriptName] = path
                        log.Printf("Discovered route script: %s at %s", scriptName, path)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error walking scripts directory: %v", err)
        }</span>
}

// ExecuteRouteScript executes a Lua script that registers routes with Chi for a specific tenant
// This version prevents segfaults by using proper state management and isolation
func (e *Engine) ExecuteRouteScript(scriptTag, tenantName string) error <span class="cov8" title="1">{
        script, exists := e.GetScript(scriptTag)
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("no route script found for tag: %s", scriptTag)
        }</span>

        // Create isolated Lua state - this prevents shared state segfaults
        <span class="cov8" title="1">L := lua.NewState(lua.Options{
                CallStackSize: LuaCallStackSize,
                RegistrySize:  LuaRegistrySize,
        })
        defer L.Close()

        // Setup basic bindings first
        e.setupBasicBindings(L)

        // Setup Lua environment with Chi bindings
        e.SetupChiBindings(L, scriptTag, tenantName)

        // Execute script with timeout protection using context
        ctx, cancel := context.WithTimeout(context.Background(), MaxScriptExecutionTime)
        defer cancel()

        done := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                done &lt;- fmt.Errorf("panic during script execution: %v", r)
                        }</span>
                }()
                <span class="cov8" title="1">err := L.DoString(script)
                done &lt;- err</span>
        }()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Lua script execution failed: %w", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("Lua script execution timeout after %v", MaxScriptExecutionTime)</span>
        }
}

// getGlobalScript loads a global script by name
func (e *Engine) getGlobalScript(scriptTag string) (string, bool) <span class="cov8" title="1">{
        e.cacheMutex.RLock()
        if script, cached := e.globalCache[scriptTag]; cached </span><span class="cov0" title="0">{
                e.cacheMutex.RUnlock()
                return script, true
        }</span>
        <span class="cov8" title="1">e.cacheMutex.RUnlock()

        // Check if we have the path for this global script
        path, exists := e.globalPaths[scriptTag]
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>

        // Load the script content
        <span class="cov8" title="1">content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to load global script %s: %v", scriptTag, err)
                return "", false
        }</span>

        // Cache the loaded content
        <span class="cov8" title="1">e.cacheMutex.Lock()
        e.globalCache[scriptTag] = string(content)
        e.cacheMutex.Unlock()

        return string(content), true</span>
}

// ExecuteGlobalScripts executes all global scripts that apply to all tenants
func (e *Engine) ExecuteGlobalScripts() error <span class="cov8" title="1">{
        for globalScriptName := range e.globalPaths </span><span class="cov8" title="1">{
                script, exists := e.getGlobalScript(globalScriptName)
                if !exists </span><span class="cov0" title="0">{
                        log.Printf("Failed to load global script: %s", globalScriptName)
                        continue</span>
                }
                // Create isolated Lua state - this prevents shared state segfaults
                <span class="cov8" title="1">L := lua.NewState(lua.Options{
                        CallStackSize: LuaCallStackSize,
                        RegistrySize:  LuaRegistrySize,
                })
                defer L.Close()

                // Setup basic bindings first
                e.setupBasicBindings(L)

                // Setup Lua environment with Chi bindings for global scope
                e.SetupChiBindings(L, globalScriptName, "global")

                // Execute script with timeout protection using context
                ctx, cancel := context.WithTimeout(context.Background(), MaxScriptExecutionTime)
                defer cancel()

                done := make(chan error, 1)
                go func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        done &lt;- fmt.Errorf("panic during global script execution: %v", r)
                                }</span>
                        }()
                        <span class="cov8" title="1">err := L.DoString(script)
                        done &lt;- err</span>
                }()

                <span class="cov8" title="1">select </span>{
                case err := &lt;-done:<span class="cov8" title="1">
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("global Lua script '%s' execution failed: %w", globalScriptName, err)
                        }</span>
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return fmt.Errorf("global Lua script '%s' execution timeout after %v", globalScriptName, MaxScriptExecutionTime)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// ReloadScripts clears the cache and reloads script paths from disk
func (e *Engine) ReloadScripts() error <span class="cov8" title="1">{
        e.cacheMutex.Lock()
        e.scriptCache = make(map[string]string)
        e.globalCache = make(map[string]string)
        e.cacheMutex.Unlock()
        e.scriptPaths = make(map[string]string)
        e.globalPaths = make(map[string]string)
        e.loadScriptPaths()
        return nil
}</span>

// GetLoadedScripts returns list of available script names
func (e *Engine) GetLoadedScripts() []string <span class="cov8" title="1">{
        scripts := make([]string, 0, len(e.scriptPaths))
        for name := range e.scriptPaths </span><span class="cov8" title="1">{
                scripts = append(scripts, name)
        }</span>
        <span class="cov8" title="1">return scripts</span>
}

// GetScriptMap returns the script paths map for testing purposes
func (e *Engine) GetScriptMap() map[string]string <span class="cov0" title="0">{
        return e.scriptPaths
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package lua

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"

        "github.com/go-chi/chi/v5"
        lua "github.com/yuin/gopher-lua"
)

// luaResponseWriter wraps http.ResponseWriter for Lua integration
type luaResponseWriter struct {
        w http.ResponseWriter
}

// LuaStatePool manages a pool of Lua states for thread-safe request handling
// This version fixes segfaults by using proper state isolation per goroutine
type LuaStatePool struct {
        pool        chan *lua.LState
        maxStates   int
        createState func() *lua.LState
        mu          sync.Mutex
        created     int
        scripts     map[string]*CompiledScript // Pre-compiled scripts to avoid re-execution
}

// CompiledScript represents a pre-compiled Lua script for faster execution
type CompiledScript struct {
        Content      string
        FunctionName string
        TenantName   string
}

// NewLuaStatePool creates a new pool of Lua states with improved thread safety
func NewLuaStatePool(maxStates int, createState func() *lua.LState) *LuaStatePool <span class="cov8" title="1">{
        return &amp;LuaStatePool{
                pool:        make(chan *lua.LState, maxStates),
                maxStates:   maxStates,
                createState: createState,
                scripts:     make(map[string]*CompiledScript),
        }
}</span>

// Get retrieves a Lua state from the pool or creates a new one
// This implementation prevents segfaults by ensuring proper state isolation
func (p *LuaStatePool) Get() *lua.LState <span class="cov8" title="1">{
        select </span>{
        case L := &lt;-p.pool:<span class="cov0" title="0">
                return L</span>
        default:<span class="cov8" title="1">
                // Pool is empty, create new state if under limit
                p.mu.Lock()
                defer p.mu.Unlock()

                if p.created &lt; p.maxStates </span><span class="cov8" title="1">{
                        p.created++
                        return p.createState()
                }</span>

                // Wait for a state to become available
                <span class="cov0" title="0">return &lt;-p.pool</span>
        }
}

// Put returns a Lua state to the pool
func (p *LuaStatePool) Put(L *lua.LState) <span class="cov8" title="1">{
        if L == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">select </span>{
        case p.pool &lt;- L:<span class="cov8" title="1"></span>
                // Successfully returned to pool
        default:<span class="cov0" title="0">
                // Pool is full, close the state
                L.Close()
                p.mu.Lock()
                p.created--
                p.mu.Unlock()</span>
        }
}

// Close closes all states in the pool
func (p *LuaStatePool) Close() <span class="cov0" title="0">{
        close(p.pool)
        for L := range p.pool </span><span class="cov0" title="0">{
                L.Close()
        }</span>
}

// RegisterScript compiles and stores a script for efficient reuse
func (p *LuaStatePool) RegisterScript(scriptKey, content, functionName, tenantName string) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        p.scripts[scriptKey] = &amp;CompiledScript{
                Content:      content,
                FunctionName: functionName,
                TenantName:   tenantName,
        }
}</span>

// GetScript retrieves a compiled script by key
func (p *LuaStatePool) GetScript(scriptKey string) (*CompiledScript, bool) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()

        script, exists := p.scripts[scriptKey]
        return script, exists
}</span>

// LuaHandler represents a thread-safe Lua function handler
// This version prevents segfaults through proper state isolation and pre-compilation
type LuaHandler struct {
        scriptKey    string
        functionName string
        tenantName   string
        scriptTag    string
        pool         *LuaStatePool
        engine       interface {
                SetupChiBindings(*lua.LState, string, string)
        }
}

// NewLuaHandler creates a new thread-safe Lua handler with script pre-compilation
func NewLuaHandler(scriptContent, functionName, tenantName, scriptTag string, pool *LuaStatePool, engine interface {
        SetupChiBindings(*lua.LState, string, string)
}) *LuaHandler <span class="cov8" title="1">{
        scriptKey := fmt.Sprintf("%s_%s", tenantName, functionName)

        // Pre-compile and register the script to avoid re-execution segfaults
        pool.RegisterScript(scriptKey, scriptContent, functionName, tenantName)

        return &amp;LuaHandler{
                scriptKey:    scriptKey,
                functionName: functionName,
                tenantName:   tenantName,
                scriptTag:    scriptTag,
                pool:         pool,
                engine:       engine,
        }
}</span>

// ServeHTTP implements http.Handler with improved thread safety and segfault prevention
func (h *LuaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        script, exists := h.pool.GetScript(h.scriptKey)
        if !exists </span><span class="cov0" title="0">{
                http.Error(w, "Script not found: "+h.scriptKey, http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">L := h.pool.Get()
        defer h.pool.Put(L)

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        h.executeScriptWithTimeout(ctx, L, script, w, r)</span>
}

// executeScriptWithTimeout executes the Lua script with proper timeout and error handling
func (h *LuaHandler) executeScriptWithTimeout(ctx context.Context, L *lua.LState, script *CompiledScript, w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        done := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                done &lt;- fmt.Errorf("panic in Lua handler: %v", r)
                        }</span>
                }()
                <span class="cov8" title="1">done &lt;- h.executeLuaScript(L, script, w, r)</span>
        }()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "Lua handler error: "+err.Error(), http.StatusInternalServerError)
                }</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                http.Error(w, "Lua handler timeout", http.StatusRequestTimeout)</span>
        }
}

// executeLuaScript executes the actual Lua script and calls the handler function
func (h *LuaHandler) executeLuaScript(L *lua.LState, script *CompiledScript, w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        // Set up Chi bindings for this execution context with correct script tag
        if h.engine != nil </span><span class="cov8" title="1">{
                h.engine.SetupChiBindings(L, h.scriptTag, h.tenantName)
        }</span>

        // Execute script only once per state (not per request) to avoid re-compilation segfaults
        <span class="cov8" title="1">if err := L.DoString(script.Content); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("script execution error: %w", err)
        }</span>

        // Get the handler function
        <span class="cov8" title="1">handlerFunc := L.GetGlobal(h.functionName)
        if handlerFunc.Type() != lua.LTFunction </span><span class="cov0" title="0">{
                return fmt.Errorf("handler function not found: %s", h.functionName)
        }</span>

        // Create safe request/response wrappers and call the handler
        <span class="cov8" title="1">return h.callLuaHandler(L, handlerFunc.(*lua.LFunction), w, r)</span>
}

// callLuaHandler creates the Lua request/response objects and calls the handler function
func (h *LuaHandler) callLuaHandler(L *lua.LState, handlerFunc *lua.LFunction, w http.ResponseWriter, r *http.Request) error <span class="cov8" title="1">{
        respWriter := &amp;luaResponseWriter{w: w}
        respTable := createLuaResponse(L, respWriter)
        reqTable := createLuaRequest(L, r)

        return L.CallByParam(lua.P{
                Fn:      handlerFunc,
                NRet:    0,
                Protect: true,
        }, respTable, reqTable)
}</span>

// createLuaRequest creates a Lua table representing an HTTP request
func createLuaRequest(L *lua.LState, r *http.Request) *lua.LTable <span class="cov8" title="1">{
        reqTable := L.NewTable()

        // Basic request info
        reqTable.RawSetString("method", lua.LString(r.Method))
        reqTable.RawSetString("url", lua.LString(r.URL.String()))
        reqTable.RawSetString("path", lua.LString(r.URL.Path))
        reqTable.RawSetString("host", lua.LString(r.Host))

        // Headers
        headersTable := L.NewTable()
        for key, values := range r.Header </span><span class="cov0" title="0">{
                if len(values) &gt; 0 </span><span class="cov0" title="0">{
                        headersTable.RawSetString(key, lua.LString(values[0]))
                }</span>
        }
        <span class="cov8" title="1">reqTable.RawSetString("headers", headersTable)

        // URL parameters (populated by Chi)
        paramsTable := L.NewTable()
        if r.Context() != nil </span><span class="cov8" title="1">{
                if rctx := chi.RouteContext(r.Context()); rctx != nil </span><span class="cov8" title="1">{
                        for i, key := range rctx.URLParams.Keys </span><span class="cov8" title="1">{
                                if i &lt; len(rctx.URLParams.Values) </span><span class="cov8" title="1">{
                                        paramsTable.RawSetString(key, lua.LString(rctx.URLParams.Values[i]))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">reqTable.RawSetString("params", paramsTable)

        // Body content storage
        var bodyContent string
        if r.Body != nil </span><span class="cov8" title="1">{
                body, err := io.ReadAll(r.Body)
                if err == nil </span><span class="cov8" title="1">{
                        bodyContent = string(body)
                }</span>
        }

        // Helper methods with colon syntax support
        <span class="cov8" title="1">headerFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                startIdx := 1
                if L.GetTop() &gt; 1 &amp;&amp; L.Get(1) == reqTable </span><span class="cov0" title="0">{
                        startIdx = 2
                }</span>
                <span class="cov0" title="0">headerName := L.ToString(startIdx)
                headerValue := r.Header.Get(headerName)
                L.Push(lua.LString(headerValue))
                return 1</span>
        })

        // Add body() method for colon syntax support
        <span class="cov8" title="1">bodyFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                L.Push(lua.LString(bodyContent))
                return 1
        }</span>)

        <span class="cov8" title="1">reqTable.RawSetString("header", headerFunc)
        reqTable.RawSetString("body", bodyFunc)

        return reqTable</span>
}

// createLuaResponse creates a Lua table representing an HTTP response with colon method support
func createLuaResponse(L *lua.LState, w *luaResponseWriter) *lua.LTable <span class="cov8" title="1">{
        respTable := L.NewTable()

        // Create method functions that work with both colon and dot syntax
        writeFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                // Skip 'self' parameter if called with colon syntax
                startIdx := 1
                if L.GetTop() &gt; 1 &amp;&amp; L.Get(1) == respTable </span><span class="cov8" title="1">{
                        startIdx = 2
                }</span>
                <span class="cov8" title="1">content := L.ToString(startIdx)
                w.w.Write([]byte(content))
                return 0</span>
        })

        <span class="cov8" title="1">headerFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov8" title="1">{
                startIdx := 1
                if L.GetTop() &gt; 2 &amp;&amp; L.Get(1) == respTable </span><span class="cov8" title="1">{
                        startIdx = 2
                }</span>
                <span class="cov8" title="1">key := L.ToString(startIdx)
                value := L.ToString(startIdx + 1)
                w.w.Header().Set(key, value)
                return 0</span>
        })

        <span class="cov8" title="1">statusFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                startIdx := 1
                if L.GetTop() &gt; 1 &amp;&amp; L.Get(1) == respTable </span><span class="cov0" title="0">{
                        startIdx = 2
                }</span>
                <span class="cov0" title="0">statusCode := L.ToInt(startIdx)
                w.w.WriteHeader(statusCode)
                return 0</span>
        })

        <span class="cov8" title="1">jsonFunc := L.NewFunction(func(L *lua.LState) int </span><span class="cov0" title="0">{
                startIdx := 1
                if L.GetTop() &gt; 1 &amp;&amp; L.Get(1) == respTable </span><span class="cov0" title="0">{
                        startIdx = 2
                }</span>
                <span class="cov0" title="0">jsonContent := L.ToString(startIdx)
                w.w.Header().Set("Content-Type", "application/json")
                w.w.Write([]byte(jsonContent))
                return 0</span>
        })

        // Set methods on table
        <span class="cov8" title="1">respTable.RawSetString("write", writeFunc)
        respTable.RawSetString("header", headerFunc)
        respTable.RawSetString("status", statusFunc)
        respTable.RawSetString("json", jsonFunc)

        return respTable</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package routing provides routing logic for Keystone Gateway.
// It handles tenant-based routing, load balancing, and backend selection.
package routing

import (
        "log"
        "net/http"
        "net/http/httputil"
        "net/url"
        "strings"
        "sync/atomic"
        "time"

        "keystone-gateway/internal/config"

        "github.com/go-chi/chi/v5"
)

// GatewayBackend represents a proxied backend server with health status tracking.
type GatewayBackend struct {
        URL   *url.URL
        Alive atomic.Bool
}

// TenantRouter manages load balancing and backend selection for a specific tenant.
type TenantRouter struct {
        Name     string
        Backends []*GatewayBackend
        RRIndex  uint64
}

// Gateway is the main reverse proxy instance that handles routing,
// load balancing, and health checking for all configured tenants.
type Gateway struct {
        config        *config.Config
        pathRouters   map[string]*TenantRouter
        hostRouters   map[string]*TenantRouter
        hybridRouters map[string]map[string]*TenantRouter
        startTime     time.Time

        // New: Dynamic route registry for Lua-defined routes
        routeRegistry *LuaRouteRegistry
}

// NewGatewayWithRouter creates a Gateway with an existing Chi router for dynamic routing
func NewGatewayWithRouter(cfg *config.Config, router *chi.Mux) *Gateway <span class="cov8" title="1">{
        gw := &amp;Gateway{
                config:        cfg,
                pathRouters:   make(map[string]*TenantRouter),
                hostRouters:   make(map[string]*TenantRouter),
                hybridRouters: make(map[string]map[string]*TenantRouter),
                startTime:     time.Now(),
                routeRegistry: NewLuaRouteRegistry(router, nil),
        }

        gw.initializeRouters()
        return gw
}</span>

// initializeRouters sets up all tenant routers from the configuration.
func (gw *Gateway) initializeRouters() <span class="cov8" title="1">{
        for _, tenant := range gw.config.Tenants </span><span class="cov8" title="1">{
                tr := &amp;TenantRouter{
                        Name:     tenant.Name,
                        Backends: make([]*GatewayBackend, 0, len(tenant.Services)),
                }

                // Initialize backends
                for _, svc := range tenant.Services </span><span class="cov8" title="1">{
                        u, err := url.Parse(svc.URL)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: invalid URL for service %s: %v", svc.Name, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">backend := &amp;GatewayBackend{URL: u}
                        backend.Alive.Store(false) // Start as unhealthy
                        tr.Backends = append(tr.Backends, backend)</span>
                }

                // Route based on configuration
                <span class="cov8" title="1">gw.registerTenantRoutes(tenant, tr)

                // TODO: Start health checks (will be moved to health package)

                log.Printf("Initialized tenant %s with %d backends", tenant.Name, len(tr.Backends))</span>
        }
}

// registerTenantRoutes registers tenant routes based on the configuration.
func (gw *Gateway) registerTenantRoutes(tenant config.Tenant, tr *TenantRouter) <span class="cov8" title="1">{
        if len(tenant.Domains) &gt; 0 &amp;&amp; tenant.PathPrefix != "" </span><span class="cov0" title="0">{
                // Hybrid routing
                for _, domain := range tenant.Domains </span><span class="cov0" title="0">{
                        if gw.hybridRouters[domain] == nil </span><span class="cov0" title="0">{
                                gw.hybridRouters[domain] = make(map[string]*TenantRouter)
                        }</span>
                        <span class="cov0" title="0">gw.hybridRouters[domain][tenant.PathPrefix] = tr</span>
                }
        } else<span class="cov8" title="1"> if len(tenant.Domains) &gt; 0 </span><span class="cov8" title="1">{
                // Host-only routing
                for _, domain := range tenant.Domains </span><span class="cov8" title="1">{
                        gw.hostRouters[domain] = tr
                }</span>
        } else<span class="cov8" title="1"> if tenant.PathPrefix != "" </span><span class="cov8" title="1">{
                // Path-only routing
                gw.pathRouters[tenant.PathPrefix] = tr
        }</span>
}

// MatchRoute finds the appropriate tenant router for a given host and path.
func (gw *Gateway) MatchRoute(host, path string) (*TenantRouter, string) <span class="cov0" title="0">{
        host = ExtractHost(host)

        // Priority 1: Hybrid routing (host + path)
        if hostMap, exists := gw.hybridRouters[host]; exists </span><span class="cov0" title="0">{
                if matched, prefix := gw.findBestPathMatch(path, hostMap); matched != nil </span><span class="cov0" title="0">{
                        return matched, prefix
                }</span>
        }

        // Priority 2: Host-only routing
        <span class="cov0" title="0">if router, exists := gw.hostRouters[host]; exists </span><span class="cov0" title="0">{
                return router, ""
        }</span>

        // Priority 3: Path-only routing
        <span class="cov0" title="0">return gw.findBestPathMatch(path, gw.pathRouters)</span>
}

// NextBackend returns the next healthy backend using round-robin algorithm.
func (tr *TenantRouter) NextBackend() *GatewayBackend <span class="cov0" title="0">{
        if len(tr.Backends) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Round-robin with health checks
        <span class="cov0" title="0">for i := 0; i &lt; len(tr.Backends); i++ </span><span class="cov0" title="0">{
                idx := int(atomic.AddUint64(&amp;tr.RRIndex, 1) % uint64(len(tr.Backends)))
                backend := tr.Backends[idx]

                if backend.Alive.Load() </span><span class="cov0" title="0">{
                        return backend
                }</span>
        }

        // Fallback to first backend even if unhealthy
        <span class="cov0" title="0">return tr.Backends[0]</span>
}

// GetTenantRouter finds a tenant router by name.
func (gw *Gateway) GetTenantRouter(name string) *TenantRouter <span class="cov8" title="1">{
        for _, tr := range gw.pathRouters </span><span class="cov8" title="1">{
                if tr.Name == name </span><span class="cov8" title="1">{
                        return tr
                }</span>
        }
        <span class="cov0" title="0">for _, tr := range gw.hostRouters </span><span class="cov0" title="0">{
                if tr.Name == name </span><span class="cov0" title="0">{
                        return tr
                }</span>
        }
        <span class="cov0" title="0">for _, hostMap := range gw.hybridRouters </span><span class="cov0" title="0">{
                for _, tr := range hostMap </span><span class="cov0" title="0">{
                        if tr.Name == name </span><span class="cov0" title="0">{
                                return tr
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// GetConfig returns the gateway configuration.
func (gw *Gateway) GetConfig() *config.Config <span class="cov0" title="0">{
        return gw.config
}</span>

// GetStartTime returns when the gateway was started.
func (gw *Gateway) GetStartTime() time.Time <span class="cov0" title="0">{
        return gw.startTime
}</span>

// GetRouteRegistry returns the dynamic route registry
func (gw *Gateway) GetRouteRegistry() *LuaRouteRegistry <span class="cov0" title="0">{
        return gw.routeRegistry
}</span>

// extractHost extracts the hostname from a host header (removing port if present).
func ExtractHost(hostHeader string) string <span class="cov0" title="0">{
        if colonIndex := strings.Index(hostHeader, ":"); colonIndex != -1 </span><span class="cov0" title="0">{
                return hostHeader[:colonIndex]
        }</span>
        <span class="cov0" title="0">return hostHeader</span>
}

// findBestPathMatch finds the best matching path prefix from a router map
func (gw *Gateway) findBestPathMatch(path string, routers map[string]*TenantRouter) (*TenantRouter, string) <span class="cov0" title="0">{
        var matched *TenantRouter
        var matchedPrefix string

        for prefix, router := range routers </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, prefix) &amp;&amp; len(prefix) &gt; len(matchedPrefix) </span><span class="cov0" title="0">{
                        matched = router
                        matchedPrefix = prefix
                }</span>
        }

        <span class="cov0" title="0">return matched, matchedPrefix</span>
}

// CreateProxy creates a reverse proxy for the given backend
func (gw *Gateway) CreateProxy(backend *GatewayBackend, stripPrefix string) *httputil.ReverseProxy <span class="cov0" title="0">{
        proxy := httputil.NewSingleHostReverseProxy(backend.URL)

        proxy.Director = func(req *http.Request) </span><span class="cov0" title="0">{
                req.URL.Scheme = backend.URL.Scheme
                req.URL.Host = backend.URL.Host

                if stripPrefix != "" </span><span class="cov0" title="0">{
                        newPath := strings.TrimPrefix(req.URL.Path, stripPrefix)
                        if newPath == "" </span><span class="cov0" title="0">{
                                newPath = "/"
                        }</span>
                        <span class="cov0" title="0">req.URL.Path = newPath</span>
                }

                // Merge query parameters
                <span class="cov0" title="0">if backend.URL.RawQuery == "" || req.URL.RawQuery == "" </span><span class="cov0" title="0">{
                        req.URL.RawQuery = backend.URL.RawQuery + req.URL.RawQuery
                }</span> else<span class="cov0" title="0"> {
                        req.URL.RawQuery = backend.URL.RawQuery + "&amp;" + req.URL.RawQuery
                }</span>
        }

        <span class="cov0" title="0">return proxy</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package routing provides dynamic route registration capabilities for Lua scripts.
// This file defines the API that allows Lua scripts to register routes, middleware,
// and route groups directly with the Chi router at runtime.
package routing

import (
        "fmt"
        "net/http"
        "sync"

        "github.com/go-chi/chi/v5"
        lua "github.com/yuin/gopher-lua"
)

// LuaRouteRegistry manages dynamic route registration from Lua scripts with thread safety
type LuaRouteRegistry struct {
        router           *chi.Mux
        routeGroups      map[string]*chi.Mux // tenant -&gt; submux for tenant routes
        registeredRoutes map[string]bool     // track registered routes to prevent duplicates
        mu               sync.RWMutex        // protects routeGroups and registeredRoutes maps
        Engine           interface {
                GetScript(string) (string, bool)
                SetupChiBindings(*lua.LState, string, string)
        }
}

// RouteDefinition represents a route registered by Lua
type RouteDefinition struct {
        TenantName string
        Method     string
        Pattern    string
        Handler    http.HandlerFunc
}

// MiddlewareDefinition represents middleware registered by Lua
type MiddlewareDefinition struct {
        TenantName string
        Pattern    string // Pattern to match for middleware (e.g., "/api/*")
        Middleware func(http.Handler) http.Handler
}

// RouteGroupDefinition represents a route group registered by Lua
type RouteGroupDefinition struct {
        TenantName string
        Pattern    string
        Middleware []func(http.Handler) http.Handler
        Routes     []RouteDefinition
        Subgroups  []RouteGroupDefinition
}

// NewLuaRouteRegistry creates a new registry for Lua-defined routes
func NewLuaRouteRegistry(router *chi.Mux, engine interface {
        GetScript(string) (string, bool)
        SetupChiBindings(*lua.LState, string, string)
}) *LuaRouteRegistry <span class="cov8" title="1">{
        return &amp;LuaRouteRegistry{
                router:           router,
                routeGroups:      make(map[string]*chi.Mux),
                registeredRoutes: make(map[string]bool),
                Engine:           engine,
        }
}</span>

// RegisterRoute registers a single route from a Lua script with duplicate prevention
func (r *LuaRouteRegistry) RegisterRoute(def RouteDefinition) error <span class="cov8" title="1">{
        // Create unique route key
        routeKey := fmt.Sprintf("%s:%s:%s", def.TenantName, def.Method, def.Pattern)

        // Check if route already exists
        r.mu.Lock()
        if r.registeredRoutes[routeKey] </span><span class="cov8" title="1">{
                r.mu.Unlock()
                // Route already exists, skip registration
                return nil
        }</span>
        <span class="cov8" title="1">r.registeredRoutes[routeKey] = true
        r.mu.Unlock()

        // Get or create tenant submux
        submux := r.getTenantSubmux(def.TenantName)

        // Register the route with the appropriate method
        r.registerRouteByMethod(submux, RouteDefinition{
                Method:  def.Method,
                Pattern: def.Pattern,
                Handler: def.Handler,
        })

        return nil</span>
}

// RegisterMiddleware registers middleware for a pattern from a Lua script
func (r *LuaRouteRegistry) RegisterMiddleware(def MiddlewareDefinition) error <span class="cov0" title="0">{
        submux := r.getTenantSubmux(def.TenantName)

        // Apply middleware to the pattern
        submux.Group(func(gr chi.Router) </span><span class="cov0" title="0">{
                gr.Use(def.Middleware)
                // The actual routes will be registered later
        }</span>)

        <span class="cov0" title="0">return nil</span>
}

// RegisterRouteGroup registers a group of routes with shared middleware with duplicate prevention
func (r *LuaRouteRegistry) RegisterRouteGroup(def RouteGroupDefinition) error <span class="cov0" title="0">{
        // Create unique group key
        groupKey := fmt.Sprintf("%s:group:%s", def.TenantName, def.Pattern)

        // Check if group already exists
        r.mu.Lock()
        if r.registeredRoutes[groupKey] </span><span class="cov0" title="0">{
                r.mu.Unlock()
                // Group already exists, skip registration
                return nil
        }</span>
        <span class="cov0" title="0">r.registeredRoutes[groupKey] = true
        r.mu.Unlock()

        submux := r.getTenantSubmux(def.TenantName)

        // Create route group with pattern and middleware
        submux.Route(def.Pattern, func(gr chi.Router) </span><span class="cov0" title="0">{
                // Apply group middleware
                for _, mw := range def.Middleware </span><span class="cov0" title="0">{
                        gr.Use(mw)
                }</span>

                // Register routes in the group
                <span class="cov0" title="0">for _, route := range def.Routes </span><span class="cov0" title="0">{
                        r.registerRouteByMethod(gr, route)
                }</span>

                // Register subgroups recursively
                <span class="cov0" title="0">for _, subgroup := range def.Subgroups </span><span class="cov0" title="0">{
                        r.registerSubgroup(gr, subgroup)
                }</span>
        })

        <span class="cov0" title="0">return nil</span>
}

// MountTenantRoutes mounts all routes for a tenant under a specific path
func (r *LuaRouteRegistry) MountTenantRoutes(tenantName, mountPath string) error <span class="cov8" title="1">{
        r.mu.RLock()
        submux, exists := r.routeGroups[tenantName]
        r.mu.RUnlock()
        
        if exists </span><span class="cov8" title="1">{
                r.router.Mount(mountPath, submux)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ClearTenantRoutes removes all routes for a specific tenant
func (r *LuaRouteRegistry) ClearTenantRoutes(tenantName string) <span class="cov0" title="0">{
        delete(r.routeGroups, tenantName)
}</span>

// GetTenantRoutes returns the submux for a tenant (for inspection/debugging)
func (r *LuaRouteRegistry) GetTenantRoutes(tenantName string) *chi.Mux <span class="cov8" title="1">{
        return r.routeGroups[tenantName]
}</span>

// ListTenants returns all tenants that have registered routes
func (r *LuaRouteRegistry) ListTenants() []string <span class="cov0" title="0">{
        tenants := make([]string, 0, len(r.routeGroups))
        for tenant := range r.routeGroups </span><span class="cov0" title="0">{
                tenants = append(tenants, tenant)
        }</span>
        <span class="cov0" title="0">return tenants</span>
}

// getTenantSubmux gets or creates a submux for a tenant
func (r *LuaRouteRegistry) getTenantSubmux(tenantName string) *chi.Mux <span class="cov8" title="1">{
        // Check if submux exists (read lock)
        r.mu.RLock()
        if submux, exists := r.routeGroups[tenantName]; exists </span><span class="cov0" title="0">{
                r.mu.RUnlock()
                return submux
        }</span>
        <span class="cov8" title="1">r.mu.RUnlock()

        // Create new submux for tenant (write lock)
        r.mu.Lock()
        defer r.mu.Unlock()

        // Double-check pattern - another goroutine might have created it
        if submux, exists := r.routeGroups[tenantName]; exists </span><span class="cov0" title="0">{
                return submux
        }</span>

        <span class="cov8" title="1">submux := chi.NewMux()
        r.routeGroups[tenantName] = submux
        return submux</span>
}

// registerSubgroup recursively registers subgroups
func (r *LuaRouteRegistry) registerSubgroup(parent chi.Router, def RouteGroupDefinition) <span class="cov0" title="0">{
        parent.Route(def.Pattern, func(gr chi.Router) </span><span class="cov0" title="0">{
                // Apply group middleware
                for _, mw := range def.Middleware </span><span class="cov0" title="0">{
                        gr.Use(mw)
                }</span>

                // Register routes in the subgroup
                <span class="cov0" title="0">for _, route := range def.Routes </span><span class="cov0" title="0">{
                        r.registerRouteByMethod(gr, route)
                }</span>
                // Register nested subgroups
                <span class="cov0" title="0">for _, subgroup := range def.Subgroups </span><span class="cov0" title="0">{
                        r.registerSubgroup(gr, subgroup)
                }</span>
        })
}

// RouteRegistryAPI provides the high-level API for Lua script integration
type RouteRegistryAPI struct {
        registry *LuaRouteRegistry
}

// NewRouteRegistryAPI creates a new API wrapper
func NewRouteRegistryAPI(router *chi.Mux) *RouteRegistryAPI <span class="cov0" title="0">{
        return &amp;RouteRegistryAPI{
                registry: NewLuaRouteRegistry(router, nil),
        }
}</span>

// Route registers a simple route (called from Lua via chi_route function)
func (api *RouteRegistryAPI) Route(tenantName, method, pattern string, handler http.HandlerFunc) error <span class="cov0" title="0">{
        return api.registry.RegisterRoute(RouteDefinition{
                TenantName: tenantName,
                Method:     method,
                Pattern:    pattern,
                Handler:    handler,
        })
}</span>

// Middleware registers middleware for a pattern (called from Lua via chi_middleware function)
func (api *RouteRegistryAPI) Middleware(tenantName, pattern string, middleware func(http.Handler) http.Handler) error <span class="cov0" title="0">{
        return api.registry.RegisterMiddleware(MiddlewareDefinition{
                TenantName: tenantName,
                Pattern:    pattern,
                Middleware: middleware,
        })
}</span>

// Group registers a route group (called from Lua via chi_group function)
func (api *RouteRegistryAPI) Group(tenantName, pattern string, middleware []func(http.Handler) http.Handler, setupFunc func(*RouteRegistryAPI)) error <span class="cov0" title="0">{
        // This will be used by the Lua bindings to set up groups
        // The setupFunc will be called with the API to register routes within the group
        def := RouteGroupDefinition{
                TenantName: tenantName,
                Pattern:    pattern,
                Middleware: middleware,
                Routes:     []RouteDefinition{},
                Subgroups:  []RouteGroupDefinition{},
        }

        return api.registry.RegisterRouteGroup(def)
}</span>

// Mount mounts tenant routes under a path (called from Lua via chi_mount function)
func (api *RouteRegistryAPI) Mount(tenantName, mountPath string) error <span class="cov0" title="0">{
        return api.registry.MountTenantRoutes(tenantName, mountPath)
}</span>

// Clear removes all routes for a tenant
func (api *RouteRegistryAPI) Clear(tenantName string) <span class="cov0" title="0">{
        api.registry.ClearTenantRoutes(tenantName)
}</span>

// registerRouteByMethod consolidates the duplicate route registration logic
func (r *LuaRouteRegistry) registerRouteByMethod(router chi.Router, route RouteDefinition) <span class="cov8" title="1">{
        switch route.Method </span>{
        case "GET":<span class="cov8" title="1">
                router.Get(route.Pattern, route.Handler)</span>
        case "POST":<span class="cov0" title="0">
                router.Post(route.Pattern, route.Handler)</span>
        case "PUT":<span class="cov0" title="0">
                router.Put(route.Pattern, route.Handler)</span>
        case "DELETE":<span class="cov0" title="0">
                router.Delete(route.Pattern, route.Handler)</span>
        case "PATCH":<span class="cov0" title="0">
                router.Patch(route.Pattern, route.Handler)</span>
        case "OPTIONS":<span class="cov0" title="0">
                router.Options(route.Pattern, route.Handler)</span>
        case "HEAD":<span class="cov0" title="0">
                router.Head(route.Pattern, route.Handler)</span>
        default:<span class="cov0" title="0">
                router.Method(route.Method, route.Pattern, route.Handler)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
