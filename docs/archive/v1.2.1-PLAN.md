# Implementation Plan: v1.2.1 "Performance Boost"

## ðŸŽ¯ **Release Goals**
- **Target**: 20-30% performance improvement (~200 req/sec)
- **Timeline**: 1 week development + 1 week testing
- **Risk Level**: LOW âš ï¸
- **Complexity**: Minimal changes to existing code

---

## ðŸ”§ **Specific Optimizations**

### **1. HTTP Transport Optimization**
```go
// Current: Using default transport
proxy := httputil.NewSingleHostReverseProxy(backend.url)

// New: Optimized transport with connection pooling
var optimizedTransport = &http.Transport{
    MaxIdleConns:        100,              // Global connection pool
    MaxIdleConnsPerHost: 10,               // Per-host connection reuse
    IdleConnTimeout:     90 * time.Second, // Keep connections alive longer
    DisableCompression:  true,             // We'll handle compression ourselves
    WriteBufferSize:     32 * 1024,        // 32KB write buffer
    ReadBufferSize:      32 * 1024,        // 32KB read buffer
}

proxy := httputil.NewSingleHostReverseProxy(backend.url)
proxy.Transport = optimizedTransport
```

### **2. Fast Host Extraction**
```go
// Current: Uses strings.Index (slower)
func extractHost(hostHeader string) string {
    if colonIndex := strings.Index(hostHeader, ":"); colonIndex != -1 {
        return hostHeader[:colonIndex]
    }
    return hostHeader
}

// New: Uses strings.IndexByte (faster)
func extractHostFast(hostHeader string) string {
    if colonIndex := strings.IndexByte(hostHeader, ':'); colonIndex != -1 {
        return hostHeader[:colonIndex]
    }
    return hostHeader
}
```

### **3. Pre-allocated Routing Maps**
```go
// Current: Map iteration for each request
for prefix, rt := range pathRouters {
    if strings.HasPrefix(path, prefix) {
        // ... matching logic
    }
}

// New: Pre-sorted slices for faster matching
type routeEntry struct {
    prefix string
    router *tenantRouter
    length int  // Pre-calculated for fast sorting
}

type optimizedRoutes struct {
    hostRoutes map[string]*tenantRouter
    pathRoutes []routeEntry  // Sorted by length (longest first)
}

func (or *optimizedRoutes) matchPath(path string) *tenantRouter {
    for _, entry := range or.pathRoutes {
        if strings.HasPrefix(path, entry.prefix) {
            return entry.router  // First match is longest due to sorting
        }
    }
    return nil
}
```

### **4. Response Header Optimization**
```go
// Add once during proxy setup
proxy.ModifyResponse = func(resp *http.Response) error {
    resp.Header.Set("Server", "keystone-gateway/1.2.1")
    resp.Header.Set("X-Proxy", "keystone")
    return nil
}
```

---

## ðŸ“ **Code Changes**

### **File: main.go**

#### Change 1: Add optimized transport
```go
// Add after import statements
var optimizedTransport = &http.Transport{
    MaxIdleConns:        100,
    MaxIdleConnsPerHost: 10,
    IdleConnTimeout:     90 * time.Second,
    DisableCompression:  true,
    WriteBufferSize:     32 * 1024,
    ReadBufferSize:      32 * 1024,
}
```

#### Change 2: Update extractHost function
```go
// Replace existing extractHost function
func extractHost(hostHeader string) string {
    if colonIndex := strings.IndexByte(hostHeader, ':'); colonIndex != -1 {
        return hostHeader[:colonIndex]
    }
    return hostHeader
}
```

#### Change 3: Optimize route structure in main()
```go
// Add after loading config
type routeEntry struct {
    prefix string
    router *tenantRouter
    length int
}

// Convert pathRouters map to sorted slice
pathRouteSlice := make([]routeEntry, 0, len(pathRouters))
for prefix, router := range pathRouters {
    pathRouteSlice = append(pathRouteSlice, routeEntry{
        prefix: prefix,
        router: router,
        length: len(prefix),
    })
}

// Sort by length (longest first) for optimal matching
sort.Slice(pathRouteSlice, func(i, j int) bool {
    return pathRouteSlice[i].length > pathRouteSlice[j].length
})
```

#### Change 4: Update makeHandler to use optimizations
```go
// Update proxy creation
proxy := httputil.NewSingleHostReverseProxy(backend.url)
proxy.Transport = optimizedTransport
proxy.ModifyResponse = func(resp *http.Response) error {
    resp.Header.Set("Server", "keystone-gateway/1.2.1")
    return nil
}
```

### **File: main_test.go**

#### Add performance regression tests
```go
func BenchmarkOptimizedExtractHost(b *testing.B) {
    testCases := []string{
        "example.com",
        "example.com:8080",
        "app.example.com:3000",
        "very-long-subdomain.example.com:8080",
    }
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        for _, host := range testCases {
            extractHost(host)
        }
    }
}

func BenchmarkRoutingPerformance(b *testing.B) {
    // Test routing with optimized structures
    // ... benchmark implementation
}
```

---

## ðŸ§ª **Testing Plan**

### **Performance Testing**
```bash
# Before optimization
ab -n 10000 -c 50 http://localhost:9010/api/test
# Target: ~159 req/sec

# After optimization  
ab -n 10000 -c 50 http://localhost:9010/api/test
# Target: ~200 req/sec (+25% improvement)
```

### **Regression Testing**
```bash
# Verify all existing functionality works
./test-routing.sh

# Run full test suite
go test -v

# Run performance benchmarks
go test -bench=. -benchmem
```

### **Load Testing**
```bash
# Extended load test
ab -t 300 -c 100 http://localhost:9010/api/stress

# Memory profiling
go tool pprof http://localhost:9010/debug/pprof/heap
```

---

## ðŸ“Š **Expected Results**

### **Performance Improvements**
| Metric | v1.2.0 | v1.2.1 Target | Improvement |
|--------|--------|---------------|-------------|
| Req/sec | 159 | 200+ | +25% |
| Latency | 6.3ms | 5.0ms | -20% |
| Memory | 8MB | 8MB | No change |
| CPU | Baseline | -10% | More efficient |

### **Benchmark Improvements**
```
BenchmarkExtractHost-8           OLD: 1000000   1234 ns/op
BenchmarkExtractHost-8           NEW: 2000000    618 ns/op  (-50%)

BenchmarkPathRouting-8           OLD: 500000    2456 ns/op  
BenchmarkPathRouting-8           NEW: 800000    1543 ns/op  (-37%)
```

---

## ðŸš€ **Deployment Strategy**

### **Phase 1: Development (Week 1)**
- Day 1-2: Implement transport optimization
- Day 3-4: Implement host extraction optimization  
- Day 5-6: Implement route structure optimization
- Day 7: Integration testing

### **Phase 2: Testing (Week 2)**
- Day 1-3: Performance benchmarking
- Day 4-5: Regression testing
- Day 6-7: Documentation and release prep

### **Phase 3: Release**
- Tag v1.2.1
- Update performance documentation
- Publish release notes

---

## ðŸ“‹ **Release Checklist**

### **Code Quality**
- [ ] All optimizations implemented
- [ ] No breaking changes
- [ ] Test coverage maintained
- [ ] Performance targets met

### **Testing**
- [ ] Unit tests pass
- [ ] Integration tests pass  
- [ ] Performance benchmarks improved
- [ ] Load testing successful
- [ ] Backward compatibility verified

### **Documentation**
- [ ] PERFORMANCE.md updated with new results
- [ ] CHANGELOG.md updated
- [ ] Release notes written
- [ ] Migration guide (if needed)

### **Release**
- [ ] Version tagged
- [ ] GitHub release created
- [ ] Performance comparison published
- [ ] Community notified

---

## ðŸ”„ **Rollback Plan**

If performance improvements don't meet targets or introduce issues:

1. **Identify problematic optimization**
2. **Revert specific changes** (not entire release)
3. **Test partial implementation**
4. **Document lessons learned**
5. **Plan alternative approach**

**Risk**: LOW - All changes are additive optimizations that can be easily reverted.

---

*This implementation plan provides a clear path to achieve 25%+ performance improvement while maintaining Keystone Gateway's simplicity and reliability.*
