# v1.2.1 "Foundation" Implementation Plan
*Code Organization + Performance Optimization*

## 🎯 **Release Goals**
- **Performance**: +15-20% improvement (~185 req/sec)
- **Code Quality**: Break large functions into focused modules
- **Maintainability**: Clear separation of concerns within single file
- **Risk**: LOW ⚠️ (refactoring + safe optimizations)

---

## 🔧 **Code Refactoring Strategy**

### **Current Problem Analysis**
```go
// CURRENT: makeHandler() - 70+ lines with mixed concerns
func makeHandler(...) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        // 1. Host extraction logic
        // 2. Three-tier routing logic
        // 3. Proxy setup logic
        // 4. Path rewriting logic
        // 5. Error handling logic
        // ALL IN ONE FUNCTION!
    }
}

// CURRENT: main() - 50+ lines with mixed concerns
func main() {
    // 1. Flag parsing
    // 2. Config loading
    // 3. Routing table initialization
    // 4. Health check startup
    // 5. HTTP server startup
    // ALL IN ONE FUNCTION!
}
```

---

## 📋 **Refactored Architecture**

### **1. New Type Definitions**
```go
// Centralized routing management
type RoutingTables struct {
    pathRouters   map[string]*tenantRouter
    hostRouters   map[string]*tenantRouter
    hybridRouters map[string]map[string]*tenantRouter
}

// Routing result with context
type tenantMatch struct {
    router       *tenantRouter
    matchedPrefix string
    routingType   string // "host", "path", or "hybrid"
}

// Optimized transport (singleton)
var optimizedTransport = &http.Transport{
    MaxIdleConns:        100,
    MaxIdleConnsPerHost: 10,
    IdleConnTimeout:     90 * time.Second,
    WriteBufferSize:     32 * 1024,
    ReadBufferSize:      32 * 1024,
}
```

### **2. Routing Functions (60 lines total)**
```go
// -------------------------
// Routing Functions
// -------------------------

func newRoutingTables() *RoutingTables {
    return &RoutingTables{
        pathRouters:   make(map[string]*tenantRouter),
        hostRouters:   make(map[string]*tenantRouter),
        hybridRouters: make(map[string]map[string]*tenantRouter),
    }
}

func extractHostFast(hostHeader string) string {
    if colonIndex := strings.IndexByte(hostHeader, ':'); colonIndex != -1 {
        return hostHeader[:colonIndex]
    }
    return hostHeader
}

func (rt *RoutingTables) findTenant(r *http.Request) *tenantMatch {
    host := extractHostFast(r.Host)
    path := r.URL.Path
    
    // Priority 1: Host + Path combination (hybrid routing)
    if match := rt.findHybridMatch(host, path); match != nil {
        return match
    }
    
    // Priority 2: Host-only routing
    if match := rt.findHostMatch(host); match != nil {
        return match
    }
    
    // Priority 3: Path-only routing (backward compatibility)
    return rt.findPathMatch(path)
}

func (rt *RoutingTables) findHybridMatch(host, path string) *tenantMatch {
    if hostPathMap, exists := rt.hybridRouters[host]; exists {
        var bestMatch *tenantMatch
        maxPrefixLen := 0
        
        for prefix, router := range hostPathMap {
            if strings.HasPrefix(path, prefix) && len(prefix) > maxPrefixLen {
                maxPrefixLen = len(prefix)
                bestMatch = &tenantMatch{
                    router:       router,
                    matchedPrefix: prefix,
                    routingType:   "hybrid",
                }
            }
        }
        return bestMatch
    }
    return nil
}

func (rt *RoutingTables) findHostMatch(host string) *tenantMatch {
    if router, exists := rt.hostRouters[host]; exists {
        return &tenantMatch{
            router:       router,
            matchedPrefix: "",
            routingType:   "host",
        }
    }
    return nil
}

func (rt *RoutingTables) findPathMatch(path string) *tenantMatch {
    var bestMatch *tenantMatch
    maxPrefixLen := 0
    
    for prefix, router := range rt.pathRouters {
        if strings.HasPrefix(path, prefix) && len(prefix) > maxPrefixLen {
            maxPrefixLen = len(prefix)
            bestMatch = &tenantMatch{
                router:       router,
                matchedPrefix: prefix,
                routingType:   "path",
            }
        }
    }
    return bestMatch
}
```

### **3. Proxy Functions (40 lines total)**
```go
// -------------------------
// Proxy Functions
// -------------------------

func (tm *tenantMatch) serveRequest(w http.ResponseWriter, r *http.Request) {
    backend := tm.router.nextBackend()
    if backend == nil {
        http.Error(w, "no backend available", http.StatusBadGateway)
        return
    }
    
    proxy := tm.createProxy(backend)
    proxy.ServeHTTP(w, r)
}

func (tm *tenantMatch) createProxy(backend *backend) *httputil.ReverseProxy {
    proxy := httputil.NewSingleHostReverseProxy(backend.url)
    proxy.Transport = optimizedTransport
    
    proxy.Director = func(req *http.Request) {
        tm.configureRequest(req, backend)
    }
    
    proxy.ModifyResponse = func(resp *http.Response) error {
        return tm.optimizeResponse(resp)
    }
    
    return proxy
}

func (tm *tenantMatch) configureRequest(req *http.Request, backend *backend) {
    req.URL.Scheme = backend.url.Scheme
    req.URL.Host = backend.url.Host
    
    // Rewrite path: strip tenant prefix only for path-based routing
    if tm.matchedPrefix != "" {
        newPath := strings.TrimPrefix(req.URL.Path, tm.matchedPrefix)
        if newPath == "" {
            newPath = "/"
        }
        req.URL.Path = newPath
    }
    
    // Merge query parameters
    if backend.url.RawQuery == "" || req.URL.RawQuery == "" {
        req.URL.RawQuery = backend.url.RawQuery + req.URL.RawQuery
    } else {
        req.URL.RawQuery = backend.url.RawQuery + "&" + req.URL.RawQuery
    }
}

func (tm *tenantMatch) optimizeResponse(resp *http.Response) error {
    resp.Header.Set("Server", "keystone-gateway/1.2.1")
    resp.Header.Set("X-Proxy", "keystone")
    return nil
}
```

### **4. Initialization Functions (50 lines total)**
```go
// -------------------------
// Initialization Functions
// -------------------------

func initializeRouting(cfg *Config) (*RoutingTables, error) {
    rt := newRoutingTables()
    
    for _, tenant := range cfg.Tenants {
        router, err := createTenantRouter(tenant)
        if err != nil {
            return nil, fmt.Errorf("failed to create router for tenant %s: %v", tenant.Name, err)
        }
        
        if err := rt.registerTenant(tenant, router); err != nil {
            return nil, fmt.Errorf("failed to register tenant %s: %v", tenant.Name, err)
        }
        
        startHealthChecks(tenant, router)
        log.Printf("tenant %s loaded with %d service(s)", tenant.Name, len(router.backends))
    }
    
    return rt, nil
}

func createTenantRouter(tenant Tenant) (*tenantRouter, error) {
    tr := &tenantRouter{}
    
    for _, svc := range tenant.Services {
        u, err := url.Parse(svc.URL)
        if err != nil {
            return nil, fmt.Errorf("invalid service url %s: %v", svc.URL, err)
        }
        
        backend := &backend{url: u}
        backend.alive.Store(false) // assume unhealthy until first check
        tr.backends = append(tr.backends, backend)
    }
    
    return tr, nil
}

func (rt *RoutingTables) registerTenant(tenant Tenant, router *tenantRouter) error {
    if len(tenant.Domains) > 0 && tenant.PathPrefix != "" {
        // Hybrid routing: both host and path
        return rt.registerHybridTenant(tenant, router)
    } else if len(tenant.Domains) > 0 {
        // Host-only routing
        return rt.registerHostTenant(tenant, router)
    } else if tenant.PathPrefix != "" {
        // Path-only routing (backward compatibility)
        return rt.registerPathTenant(tenant, router)
    }
    
    return fmt.Errorf("tenant must specify either domains or path_prefix")
}

func (rt *RoutingTables) registerHybridTenant(tenant Tenant, router *tenantRouter) error {
    for _, domain := range tenant.Domains {
        if rt.hybridRouters[domain] == nil {
            rt.hybridRouters[domain] = make(map[string]*tenantRouter)
        }
        rt.hybridRouters[domain][tenant.PathPrefix] = router
        log.Printf("tenant %s: hybrid routing for domain %s with path %s", tenant.Name, domain, tenant.PathPrefix)
    }
    return nil
}

func (rt *RoutingTables) registerHostTenant(tenant Tenant, router *tenantRouter) error {
    for _, domain := range tenant.Domains {
        rt.hostRouters[domain] = router
        log.Printf("tenant %s: host-based routing for domain %s", tenant.Name, domain)
    }
    return nil
}

func (rt *RoutingTables) registerPathTenant(tenant Tenant, router *tenantRouter) error {
    rt.pathRouters[tenant.PathPrefix] = router
    log.Printf("tenant %s: path-based routing for prefix %s", tenant.Name, tenant.PathPrefix)
    return nil
}
```

### **5. Simplified makeHandler and main**
```go
// -------------------------
// HTTP Handler (15 lines)
// -------------------------

func makeHandler(routers *RoutingTables) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        match := routers.findTenant(r)
        if match == nil {
            http.NotFound(w, r)
            return
        }
        match.serveRequest(w, r)
    }
}

// -------------------------
// Main (20 lines)
// -------------------------

func main() {
    cfgPath := flag.String("config", "config.yaml", "path to YAML config")
    addr := flag.String("addr", ":8080", "listen address")
    flag.Parse()

    cfg, err := loadConfig(*cfgPath)
    if err != nil {
        log.Fatalf("failed to load config: %v", err)
    }

    routers, err := initializeRouting(cfg)
    if err != nil {
        log.Fatalf("failed to initialize routing: %v", err)
    }

    http.HandleFunc("/", makeHandler(routers))
    
    log.Printf("Keystone Gateway listening on %s", *addr)
    if err := http.ListenAndServe(*addr, nil); err != nil {
        log.Fatal(err)
    }
}
```

---

## 📊 **Performance Improvements**

### **1. HTTP Transport Optimization**
- Connection pooling with `MaxIdleConns: 100`
- Per-host connection reuse with `MaxIdleConnsPerHost: 10`
- Larger buffers: 32KB read/write buffers
- **Expected gain**: +8-10%

### **2. Fast Host Extraction**
- Replace `strings.Index` with `strings.IndexByte`
- Avoid unnecessary string operations
- **Expected gain**: +2-3%

### **3. Response Header Optimization**
- Pre-set common headers via `ModifyResponse`
- Reduce header manipulation overhead
- **Expected gain**: +2-3%

### **4. Code Efficiency**
- Eliminate redundant string operations
- Better memory allocation patterns
- Cleaner function call chains
- **Expected gain**: +3-5%

**Total Expected Performance Gain**: +15-20% (~185 req/sec)

---

## 🧪 **Testing Strategy**

### **1. Backward Compatibility**
```bash
# Ensure all existing routing scenarios still work
./test-routing.sh
```

### **2. Performance Regression**
```bash
# Benchmark before and after refactoring
ab -n 10000 -c 50 http://localhost:8080/api/test
```

### **3. Function-Level Testing**
```go
func TestRoutingTables_FindTenant(t *testing.T) {
    // Test each routing method individually
}

func TestTenantMatch_ServeRequest(t *testing.T) {
    // Test proxy setup and serving
}
```

---

## 📁 **File Structure (Still Single File)**
```
main.go (270 lines - down from 314)
├── Imports & Types                 (40 lines)
├── Configuration Functions         (30 lines)
├── Routing Functions              (60 lines)
├── Proxy Functions                (40 lines)
├── Initialization Functions       (50 lines)
├── Health Check Functions         (30 lines)
├── Main Handler & Server          (30 lines)
```

---

## ✅ **Implementation Checklist**

- [ ] Create new type definitions (`RoutingTables`, `tenantMatch`)
- [ ] Implement routing functions (`findTenant`, `findHybridMatch`, etc.)
- [ ] Implement proxy functions (`serveRequest`, `createProxy`, etc.)
- [ ] Implement initialization functions (`initializeRouting`, `createTenantRouter`)
- [ ] Refactor `makeHandler` to use new structure
- [ ] Refactor `main` to use new initialization
- [ ] Add HTTP transport optimization
- [ ] Add response header optimization
- [ ] Update tests for new function structure
- [ ] Run performance benchmarks
- [ ] Validate backward compatibility
- [ ] Update documentation

---

## 🎯 **Success Criteria**

### **Code Quality**
- ✅ No function > 30 lines
- ✅ Clear separation of concerns
- ✅ Single responsibility per function
- ✅ Maintainable and readable code

### **Performance**
- ✅ 15-20% throughput improvement
- ✅ No latency regression
- ✅ Efficient memory usage

### **Compatibility**
- ✅ 100% backward compatibility
- ✅ All existing tests pass
- ✅ All routing scenarios work

---

*This refactoring creates a solid foundation for future enhancements while maintaining Keystone's single-file philosophy and improving both performance and maintainability.*
